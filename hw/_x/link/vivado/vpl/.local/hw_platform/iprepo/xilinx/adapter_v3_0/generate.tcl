proc gen_adapter {num} {
    if {[file exists "hdl/adapter.v"]} {
	file delete -force "hdl/adapter.v"
    }
    set fp [open "hdl/adapter.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module adapter #("
    puts $fp "    parameter C_ACC_RESET_POLARITY = 0, //active reset value (zero is active low, one is active high)"
    puts $fp "    parameter C_NUM_INPUT_SCALARS = 0,"
    puts $fp "    parameter C_NUM_OUTPUT_SCALARS = 0,"
    puts $fp "    parameter C_QUEUE_DEPTH = 16,"
    puts $fp "    parameter C_NUM_INPUT_FIFOs = 0,"
    puts $fp "    parameter C_NUM_OUTPUT_FIFOs = 0,"
    puts $fp "    parameter C_NUM_OUTPUT_BRAMs = 0,"
    puts $fp "    parameter C_NUM_INPUT_BRAMs = 0"
    puts $fp " ) ("
    puts $fp "    //axi lite interface "
    puts $fp "    input S_AXI_ACLK,"
    puts $fp "    input S_AXI_ARESETN,"
    puts $fp "    input \[31 : 0\] S_AXI_AWADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_AWPROT,"
    puts $fp "    input S_AXI_AWVALID,"
    puts $fp "    output S_AXI_AWREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_WDATA,"
    puts $fp "    input \[3 : 0\] S_AXI_WSTRB,"
    puts $fp "    input S_AXI_WVALID,"
    puts $fp "    output S_AXI_WREADY,"
    puts $fp "    output \[1 : 0\] S_AXI_BRESP,"
    puts $fp "    output S_AXI_BVALID,"
    puts $fp "    input S_AXI_BREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_ARADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_ARPROT,"
    puts $fp "    input S_AXI_ARVALID,"
    puts $fp "    output S_AXI_ARREADY,"
    puts $fp "    output \[31 : 0\] S_AXI_RDATA,"
    puts $fp "    output \[1 : 0\] S_AXI_RRESP,"
    puts $fp "    output S_AXI_RVALID,"
    puts $fp "    input S_AXI_RREADY,"
    puts $fp "    //acc clock"
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_rstn,"
    puts $fp "    //acc interface   "
    puts $fp "    output ap_rst,"
    puts $fp "    output ap_start,"
    puts $fp "    output ap_start_single,"
    puts $fp "    input ap_idle,"
    puts $fp "    input ap_done,"
    puts $fp "    input ap_ready,"
    puts $fp "    output ap_continue,"
    puts $fp "    output ap_clk,"
    puts $fp "    //scalar interface"
    puts $fp "    output \[31:0\] scalar_write_addr,"
    puts $fp "    output \[31:0\] scalar_read_addr,"
    puts $fp "    output \[31:0\] scalar_din,"
    puts $fp "    output scalar_we,"
    puts $fp "    output scalar_re,"
    puts $fp "    input \[31:0\] scalar_dout,"
    puts $fp "    output \[C_NUM_INPUT_SCALARS-1:0\] inscalar_next,"
    puts $fp "    input \[C_NUM_INPUT_SCALARS-1:0\] inscalar_fifo_empty,"
    puts $fp "    input \[C_NUM_INPUT_SCALARS-1:0\] inscalar_fifo_full,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_fifo_empty,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_fifo_full,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_empty,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_dout,"
    puts $fp "    output \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_read,"
    puts $fp "    //input argument control interface"
    puts $fp "    output inbram_ctrl_allow,"
    puts $fp "    input \[C_NUM_INPUT_BRAMs-1:0\] inbram_ctrl_ready,"
    puts $fp "    input \[C_NUM_INPUT_BRAMs-1:0\] inoutbram_ctrl_ready,"
    puts $fp "    //input argument control interface"
    puts $fp "    output infifo_ctrl_allow,"
    puts $fp "    //output bram control interface"
    puts $fp "    output outbram_ctrl_allow,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_ready,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_canstart,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write,"
    puts $fp "    //output fifo control interface"
    puts $fp "    output outfifo_ctrl_allow,"
    puts $fp "    //input axis control interface"
    puts $fp "    output inaxis_ctrl_allow,"
    puts $fp "    //output axis control interface"
    puts $fp "    output outaxis_ctrl_allow,"
	puts $fp "    output ap_done_irq"
    puts $fp "    );"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX = ${num}; //maximum quantity of scalars, fifos, brams"
    puts $fp "    "
    puts $fp "    localparam idle=0,update=1,wait_deps=2,start=3,wait_done=4;"
    puts $fp "    reg \[2:0\] ctrl_state = idle;"
    puts $fp "    "
    puts $fp "    integer idx;"
    puts $fp "    "
    puts $fp "    reg \[31:0\] slv_reg_in;"
    puts $fp "    reg slv_reg_in_vld;"
    puts $fp "    wire \[31:0\] slv_reg_out;"
    puts $fp "    wire slv_reg_out_vld;"
    puts $fp "    wire \[13:0\] slv_reg_addr;"
    puts $fp "    wire slv_reg_addr_vld;"
    puts $fp ""
    puts $fp "    wire \[C_MAX-1:0\] outscalar_fifo_empty_i;"
    puts $fp "    wire \[C_MAX-1:0\] outscalar_fifo_full_i;"
    puts $fp "    reg \[C_MAX-1:0\] outscalar_null_read_i;"
    puts $fp "    wire \[C_MAX-1:0\] outscalar_null_empty_i;"
    puts $fp "    wire \[C_MAX-1:0\] outscalar_null_dout_i;"
    puts $fp "    wire \[C_MAX-1:0\] inscalar_fifo_empty_i;"
    puts $fp "    wire \[C_MAX-1:0\] inscalar_fifo_full_i;"
    puts $fp "    reg \[C_MAX*32-1:0\] outbram_depth_i;"
    puts $fp "    reg \[C_MAX-1:0\] outbram_depth_write_i;"
    puts $fp "    "
    puts $fp "    reg ap_rst_i;"
    puts $fp "    "
    puts $fp "    reg start_core;         //signal to start acc core"
    puts $fp "    "
    puts $fp "    reg running_core;       //state of accelerator is running"
    puts $fp "    "
    puts $fp "    wire \[31:0\] cmd_dout;    //data out from command queue"
    puts $fp "    wire cmd_read;           //read signal to command queue"
    puts $fp "    reg cmd_write;           //write signal to command queue"
    puts $fp "    wire cmd_empty;          //empty signal from command queue"
    puts $fp "    wire cmd_full;           //full signal from command queue"
    puts $fp "    "
    puts $fp "    wire done_dout;          //data out from done queue"
    puts $fp "    reg done_read;           //read signal to done queue"
    puts $fp "    wire done_empty;         //empty signal from done queue"
    puts $fp "    wire done_full;          //full signal from done queue"
    puts $fp "    "
    puts $fp "    wire \[31:0\] control_reg;  //control register 0"
    puts $fp "    wire \[31:0\] status_reg;  //status register 1"
    puts $fp "    "
    puts $fp "    //scalar registers"
    puts $fp "    reg \[31:0\] scalar_write_addr_i;"
    puts $fp "    reg \[31:0\] scalar_read_addr_i;"
    puts $fp "    reg scalar_we_i;"
    puts $fp "    reg scalar_re_i;"
    puts $fp "    "
    puts $fp "    //accelerator assignments"
    puts $fp "    assign ap_rst = ((acc_rstn) ? (~C_ACC_RESET_POLARITY) : C_ACC_RESET_POLARITY);"
    puts $fp "    assign ap_continue = 0;"
    puts $fp "    assign ap_clk = acc_clk;"
    puts $fp "    "
    puts $fp "    //scalar assignments"
    puts $fp "    assign scalar_write_addr = scalar_write_addr_i;"
    puts $fp "    assign scalar_read_addr = scalar_read_addr_i;"
    puts $fp "    assign scalar_din = slv_reg_out;"
    puts $fp "    assign scalar_we = scalar_we_i;"
    puts $fp "    assign scalar_re = scalar_re_i;"
	puts $fp "    "
    puts $fp "    generate"
    puts $fp "        if(C_NUM_OUTPUT_SCALARS > 0) begin"
    puts $fp "            assign outscalar_null_read\[C_NUM_OUTPUT_SCALARS-1:0\] = outscalar_null_read_i\[C_NUM_OUTPUT_SCALARS-1:0\];"
    puts $fp "            assign outscalar_null_empty_i\[C_NUM_OUTPUT_SCALARS-1:0\] = {{(C_MAX-C_NUM_OUTPUT_SCALARS){1'b0}},outscalar_null_empty};"
    puts $fp "            assign outscalar_null_dout_i\[C_NUM_OUTPUT_SCALARS-1:0\] = {{(C_MAX-C_NUM_OUTPUT_SCALARS){1'b0}},outscalar_null_dout};"
    puts $fp "        end"
    puts $fp "        else begin"
    puts $fp "            assign outscalar_null_empty_i = {C_MAX{1'b0}};"
    puts $fp "            assign outscalar_null_dout_i = {C_MAX{1'b0}};"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //bram assignments"
    puts $fp "    generate"
    puts $fp "       if(C_NUM_OUTPUT_BRAMs > 0) begin"
    puts $fp "	       assign outbram_depth = outbram_depth_i\[C_NUM_OUTPUT_BRAMs*32-1:0\];"
    puts $fp "	       assign outbram_depth_write = outbram_depth_write_i\[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "       end"
    puts $fp "       else begin"
    puts $fp "	       assign outbram_depth = 0;"
    puts $fp "	       assign outbram_depth_write = 0;"
    puts $fp "       end"
    puts $fp "    endgenerate"
    puts $fp "        "
    puts $fp "    //internal signal assignments"
    puts $fp "    assign control_reg\[0\] = 0;      //start reset signal - unused"
    puts $fp "    assign control_reg\[1\] = 0; //reset ongoing status - unused"
    puts $fp "    assign control_reg\[31:2\] = 0;            //unused"
    puts $fp "    "
    puts $fp "    assign status_reg\[0\] = 0;    //TDB: core running status bit"
    puts $fp "    assign status_reg\[1\] = 0;       //registered acc done bit (COR) - unimplemented"
    puts $fp "    assign status_reg\[2\] = 0;         //straight ap_idle signal - unimplemented"
    puts $fp "    assign status_reg\[3\] = 0;        //straight ap_ready signal - unimplemented"
    puts $fp "    assign status_reg\[4\] = 0;       //done full signal from queue - unimplemented (CDC)"
    puts $fp "    assign status_reg\[5\] = done_empty;      //done empty signal from queue"
    puts $fp "    assign status_reg\[6\] = done_dout;       //done data out signal from queue"
    puts $fp "    assign status_reg\[31:7\] = 0;            //unused"
    puts $fp ""
	puts $fp "    assign ap_done_irq = done_dout && !done_empty;"					
    puts $fp ""
    puts $fp "    //set in/out scalar status based on number of enabled in/out scalars"
    puts $fp "    genvar i;"
    puts $fp "    generate"
    puts $fp "        if(C_NUM_OUTPUT_SCALARS == 0) begin"
    puts $fp "            assign outscalar_fifo_full_i = 0;"
    puts $fp "            assign outscalar_fifo_empty_i = 0;"
    puts $fp "        end"
    puts $fp "        "
    puts $fp "        if(C_NUM_INPUT_SCALARS == 0) begin"
    puts $fp "            assign inscalar_fifo_full_i = 0;"
    puts $fp "            assign inscalar_fifo_empty_i = 0;"
    puts $fp "        end"
    puts $fp "        "
    puts $fp "        for(i=0; i<C_NUM_OUTPUT_SCALARS; i=i+1) begin : OUTSCALAR_ASSIGN"
    puts $fp "            assign outscalar_fifo_full_i\[i\] = outscalar_fifo_full\[i\];"
    puts $fp "            assign outscalar_fifo_empty_i\[i\] = outscalar_fifo_empty\[i\];"
    puts $fp "        end"
    puts $fp "        for(i=0; i<C_NUM_INPUT_SCALARS; i=i+1) begin : INSCALAR_ASSIGN"
    puts $fp "            assign inscalar_fifo_full_i\[i\] = inscalar_fifo_full\[i\];"
    puts $fp "            assign inscalar_fifo_empty_i\[i\] = inscalar_fifo_empty\[i\];"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "            "
    puts $fp "    //write address decode, register map implementation"
    puts $fp "    always @(posedge S_AXI_ACLK) begin"
    puts $fp "       //default values"
    puts $fp "       outbram_depth_write_i <= 0;"
    puts $fp "       "
    puts $fp "        if(S_AXI_ARESETN == 0) begin"
    puts $fp "            //values to set on reset"
    puts $fp "        end"
    puts $fp "        else begin"
    puts $fp "            if(slv_reg_out_vld) begin"
    puts $fp "                case(slv_reg_addr)"
    puts $fp "                    14'd0: begin"
    puts $fp "                        //slv_reg_out\[0\];  //write 1 to bit 0 to start reset sequence - unimplemented"
    puts $fp "                        //slv_reg_out\[31:1\], read only"
    puts $fp "                    end"
    puts $fp "                    14'd1: begin"
    puts $fp "                        //slv_reg_out\[0\], read only"
    puts $fp "                        //slv_reg_out\[1\]; done clean - unused"
    puts $fp "                        //slv_reg_out\[31:2\], read only"
    puts $fp "                    end"
    puts $fp "                    //14'd2 command reg implemented in non-clocked process"
    set iscalar_num [expr $num + 2]
    puts $fp "		          //14'd${iscalar_num}-3 input scalar, implemented in non-clocked process"
    set oscalar_start [expr $iscalar_num + 1]
    set oscalar_stop [expr $oscalar_start + $num - 1]
    puts $fp "                    //14'd${oscalar_stop}-${oscalar_start} output scalar, read-only"
    set istatus_start [expr $oscalar_stop + 1]
    set istatus_stop [expr $istatus_start + $num - 1]
    puts $fp "                    //14'd${istatus_stop}-${istatus_start} input scalar status, read-only"
    set ostatus_start [expr $istatus_stop + 1]
    set ostatus_stop [expr $ostatus_start + $num - 1]
    puts $fp "                    //14'd${ostatus_stop}-${ostatus_start} output scalar status, read-only"
    set depth_start [expr $ostatus_stop + 1]
    for {set idx 0} {$idx < $num} {incr idx} {
	set depth [expr $depth_start + $idx]
	set start [expr 32 * $idx]
	set stop [expr $start + 31]
	puts $fp "                    14'd${depth}: begin  //output arg${idx} length"
	puts $fp "                        outbram_depth_i\[${stop}:${start}\] <= slv_reg_out;"
	puts $fp "                        outbram_depth_write_i\[${idx}\] <= 1;"
	puts $fp "                    end"
    }
    puts $fp "                    default: begin"
    puts $fp "                    end"
    puts $fp "                endcase"
    puts $fp "            end"
    puts $fp "        end "
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //combinational logic for scalar module write-enable (we) generation and address translation (adapter address to scalar module addressing)"
    puts $fp "    always @(*) begin"
    puts $fp "        //default values"
    puts $fp "       scalar_write_addr_i <= 0;"
    puts $fp "        scalar_we_i <= 0;"
    puts $fp "        cmd_write <= 0;"
    puts $fp "        "
    puts $fp "        if(slv_reg_out_vld) begin"
    puts $fp "            case(slv_reg_addr)"
    puts $fp "                //14'd0 control reg, implemented in clocked process"
    puts $fp "                //14'd1 status reg, implemented in clocked process"
    puts $fp "                14'd2: begin  //command reg"
    puts $fp "                    cmd_write <= 1;"
    puts $fp "                end"
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr 3 + $idx]
	puts $fp "                14'd${addr}: begin  //input scalar ${idx}"
	puts $fp "                    scalar_we_i <= 1;"
	puts $fp "                    scalar_write_addr_i <= ${idx};"
	puts $fp "                end"
    }
    puts $fp "                //14'd${oscalar_stop}-${oscalar_start} output scalar, read-only"
    puts $fp "                //14'd${istatus_stop}-${istatus_start} input scalar status, read-only"
    puts $fp "                //14'd${ostatus_stop}-${ostatus_start} output scalar status, read-only"
    set oarg_start [expr $ostatus_stop + 1]
    set oarg_stop [expr $oarg_start + $num - 1]
    puts $fp "                //14'd${oarg_stop}-${oarg_start} output argument length, implemented in clocked process"
    puts $fp "                default: begin"
    puts $fp "                end"
    puts $fp "            endcase"
    puts $fp "        end"
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //read address decode, register map implementation"
    puts $fp "    always @(*) begin"
    puts $fp "        //default values"
    puts $fp "        slv_reg_in <= 32'h5eaf000d;"
    puts $fp "        slv_reg_in_vld <= 0;"    
    puts $fp "        scalar_read_addr_i <= 0;"
    puts $fp "        scalar_re_i <= 0;"
    puts $fp "        outscalar_null_read_i <= {C_MAX{1'b0}};"
    puts $fp "        done_read <= 0;"
    puts $fp "       "
    puts $fp "        if(slv_reg_addr_vld) begin"
    puts $fp "            case(slv_reg_addr)"
    puts $fp "                14'd0: begin   //control register"
    puts $fp "                    slv_reg_in <= control_reg;"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                end"
    puts $fp "                14'd1: begin   //status register"
    puts $fp "                    slv_reg_in <= status_reg;"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                    if(~done_empty)"
    puts $fp "                        done_read <= 1;"
    puts $fp "                end"
    puts $fp "                14'd2: begin   //command register"
    puts $fp "                    slv_reg_in <= {26'd0,   //Reserved"
    puts $fp "			                 1'd0,           //bit\[5\] cmd_empty - unimplemented (CDC)"
    puts $fp "			                 cmd_full,    //bit\[4\]"
    puts $fp "			                 4'd0};       //bits\[3:0\] - number of elements in fifo (unimplemented)"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                end"
    puts $fp "                //14'd${iscalar_num}-3 input scalar, write only"
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $oscalar_start + $idx]
	puts $fp "                14'd${addr}: begin  //output scalar ${idx}"
	puts $fp "                    scalar_read_addr_i <= C_MAX+${idx};"
	puts $fp "                    slv_reg_in <= scalar_dout;"
	puts $fp "                    slv_reg_in_vld <= 1;"
	puts $fp "                    scalar_re_i <= 1;"
	puts $fp "                end"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $istatus_start + $idx];
	puts $fp "                14'd${addr}: begin  //input scalar ${idx} status"
	puts $fp "                        slv_reg_in <= {26'd0,                     //Reserved"
	puts $fp "                                       inscalar_fifo_empty_i\[${idx}\], //bit\[5\] - input scalar fifo empty"
	puts $fp "                                       inscalar_fifo_full_i\[${idx}\],  //bit\[4\] - input scalar fifo full"
	puts $fp "                                       4'd0};                        //bits\[3:0\] - number of elements in fifo (unimplemented)"
	puts $fp "                        slv_reg_in_vld <= 1;"
	puts $fp "                end"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $ostatus_start + $idx]
	puts $fp "                14'd${addr}: begin  //output scalar ${idx} status"
	puts $fp "                    outscalar_null_read_i\[${idx}\] <= 1;"
	puts $fp "                    slv_reg_in <= {23'd0,                       //Reserved"
	puts $fp "                                   outscalar_fifo_empty_i\[${idx}\],   //bit\[8\] - output scalar fifo empty"
	puts $fp "                                   1'b0,                               //bit\[7\] - Reserved"
	puts $fp "                                   outscalar_null_dout_i\[${idx}\],    //bit\[6\] - output scalar null fifo data out"
	puts $fp "                                   outscalar_null_empty_i\[${idx}\],   //bit\[5\] - output scalar null fifo empty"
	puts $fp "                                   1'b0,                        //bit\[4\] - output scalar null fifo full (0)"
	puts $fp "                                   4'd0};                       //bits\[3:0\] - number of elements in fifo (unimplemented)"
	puts $fp "                    slv_reg_in_vld <= 1;"
	puts $fp "                end"
    }
    puts $fp "                default: begin"
    puts $fp "                end"
    puts $fp "            endcase"
    puts $fp "        end"
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //command register queue"
    puts $fp "    fifo #( "
    puts $fp "        .WIDTH(32),"
    puts $fp "        .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "    ) cmd_queue ("
    puts $fp "        .wr_clk(S_AXI_ACLK),"
    puts $fp "        .din(slv_reg_out),"
    puts $fp "        .write(cmd_write),"
    puts $fp "        .full(cmd_full),"
    puts $fp "        .dout(cmd_dout),"
    puts $fp "        .read(cmd_read),"
    puts $fp "        .empty(cmd_empty),"
    puts $fp "        .rd_clk(acc_clk), "
    puts $fp "        .rst(0) "     
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //ap_done queue"
    puts $fp "    fifo #( "
    puts $fp "        .WIDTH(1),"
    puts $fp "        .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "    ) done_queue ("
    puts $fp "        .wr_clk(acc_clk),"
    puts $fp "        .din(1'b1),"
    puts $fp "        .write(ap_done),"
    puts $fp "        .full(done_full),"
    puts $fp "        .dout(done_dout),"
    puts $fp "        .read(done_read),"
    puts $fp "        .empty(done_empty),"
    puts $fp "        .rd_clk(S_AXI_ACLK), "
    puts $fp "        .rst(0) "     
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //command queue handler"
    puts $fp "    cmd_control #("
    puts $fp "        .NUM_INPUT_SCALARS(C_NUM_INPUT_SCALARS),"
    puts $fp "        .NUM_OUTPUT_SCALARS(C_NUM_OUTPUT_SCALARS),"
    puts $fp "        .NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    puts $fp "        .NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    puts $fp "        .NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    puts $fp "        .NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs)"
    puts $fp "    ) cmd_ctrl ("
    puts $fp "        //command queue interface"
    puts $fp "        .clk(acc_clk),"
    puts $fp "        .rstn(acc_rstn),"
    puts $fp "        .din(cmd_dout),"
    puts $fp "        .read(cmd_read),"
    puts $fp "        .empty(cmd_empty),"
    puts $fp "        .ap_start(ap_start),"
    puts $fp "        .ap_start_single(ap_start_single),"
    puts $fp "        .ap_done(ap_done),"
    puts $fp "        .ap_ready(ap_ready),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .inbram_ctrl_allow(inbram_ctrl_allow),"
    puts $fp "        .inbram_ctrl_ready(inbram_ctrl_ready),"
    puts $fp "        .inoutbram_ctrl_ready(inoutbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_allow(outbram_ctrl_allow),"
    puts $fp "        .outbram_ctrl_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_canstart(outbram_ctrl_canstart),"
    puts $fp "        .infifo_ctrl_allow(infifo_ctrl_allow),"
    puts $fp "        .outfifo_ctrl_allow(outfifo_ctrl_allow),"
    puts $fp "        .inaxis_ctrl_allow(inaxis_ctrl_allow),"
    puts $fp "        .outaxis_ctrl_allow(outaxis_ctrl_allow)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //axi lite interface module"
    puts $fp "    AXI_LITE_IF #("
    puts $fp "        .C_S_AXI_DATA_WIDTH(32)"
    puts $fp "    ) axi_lite_if_i ("
    puts $fp "        .slv_reg_in(slv_reg_in),"
    puts $fp "        .slv_reg_in_vld(slv_reg_in_vld),"
    puts $fp "        .slv_reg_out(slv_reg_out),"
    puts $fp "        .slv_reg_out_vld(slv_reg_out_vld),"
    puts $fp "        .slv_reg_addr(slv_reg_addr),"
    puts $fp "        .slv_reg_addr_vld(slv_reg_addr_vld),"
    puts $fp "        .S_AXI_ACLK(S_AXI_ACLK),"
    puts $fp "        .S_AXI_ARESETN(S_AXI_ARESETN),"
    puts $fp "        .S_AXI_AWADDR(S_AXI_AWADDR),"
    puts $fp "        .S_AXI_AWPROT(S_AXI_AWPROT),"
    puts $fp "        .S_AXI_AWVALID(S_AXI_AWVALID),"
    puts $fp "        .S_AXI_AWREADY(S_AXI_AWREADY),"
    puts $fp "        .S_AXI_WDATA(S_AXI_WDATA),"
    puts $fp "        .S_AXI_WSTRB(S_AXI_WSTRB),"
    puts $fp "        .S_AXI_WVALID(S_AXI_WVALID),"
    puts $fp "        .S_AXI_WREADY(S_AXI_WREADY),"
    puts $fp "        .S_AXI_BRESP(S_AXI_BRESP),"
    puts $fp "        .S_AXI_BVALID(S_AXI_BVALID),"
    puts $fp "        .S_AXI_BREADY(S_AXI_BREADY),"
    puts $fp "        .S_AXI_ARADDR(S_AXI_ARADDR),"
    puts $fp "        .S_AXI_ARPROT(S_AXI_ARPROT),"
    puts $fp "        .S_AXI_ARVALID(S_AXI_ARVALID),"
    puts $fp "        .S_AXI_ARREADY(S_AXI_ARREADY),"
    puts $fp "        .S_AXI_RDATA(S_AXI_RDATA),"
    puts $fp "        .S_AXI_RRESP(S_AXI_RRESP),"
    puts $fp "        .S_AXI_RVALID(S_AXI_RVALID),"
    puts $fp "        .S_AXI_RREADY(S_AXI_RREADY)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "endmodule"

    close $fp
}

proc gen_scalar {num} {
    if {[file exists "hdl/scalar.v"]} {
	file delete -force "hdl/scalar.v"
    }
    set fp [open "hdl/scalar.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module scalar #("
    puts $fp "    parameter C_NUM_INSCALARS = 0,"
    puts $fp "    parameter C_NUM_OUTSCALARS = 0,"
    puts $fp "    parameter C_FIFO_DEPTH = 16,"
    puts $fp "    parameter C_HAS_RETURN = 0,"
    puts $fp "    "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] C_INSCALAR_${idx}_BITS = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_IS_DIRECT = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_DEPTH = 16,"
    }
    puts $fp "    "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\]  C_OUTSCALAR_${idx}_BITS = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\]  M_AXIS_SCALAR_${idx}_IS_DIRECT = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_DEPTH = 16,"
	} else {
	    puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_DEPTH = 16"
	}
    }
    puts $fp " ) ("
    puts $fp "    input clk,"
    puts $fp "    input acc_clk,"
    puts $fp "    //control interface"
    puts $fp "    input \[31:0\] scalar_read_addr,"
    puts $fp "    input scalar_re,"
    puts $fp "    output \[31:0\] scalar_dout,"
    puts $fp "    input scalar_we,"
    puts $fp "    input \[31:0\] scalar_write_addr,"
    puts $fp "    input \[31:0\] scalar_din,"
    puts $fp "    input outscalar_capture,"
    puts $fp "    input \[C_NUM_INSCALARS-1:0\] inscalar_next,"
    puts $fp "    output \[C_NUM_INSCALARS-1:0\] inscalar_fifo_empty,"
    puts $fp "    output \[C_NUM_INSCALARS-1:0\] inscalar_fifo_full,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_fifo_empty,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_fifo_full,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_null_empty,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_null_dout,"
    puts $fp "    input \[C_NUM_OUTSCALARS-1:0\] outscalar_null_read,"
    puts $fp "    //input scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    output \[C_INSCALAR_${idx}_BITS-1:0\] inscalar${idx},"
    }
    puts $fp "    //input scalar direct AXIS interfaces"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to Scalar interface ${idx}"
	puts $fp "    input s_axis_scalar_${idx}_aclk,"
	puts $fp "    input s_axis_scalar_${idx}_aresetn,"
	puts $fp "    input s_axis_scalar_${idx}_tlast,"
	puts $fp "    input s_axis_scalar_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] s_axis_scalar_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] s_axis_scalar_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\] s_axis_scalar_${idx}_tdata,"
	puts $fp "    output s_axis_scalar_${idx}_tready,"
    }
    puts $fp "    //output scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input \[C_OUTSCALAR_${idx}_BITS-1:0\] outscalar${idx},"
    }
    puts $fp "    //output scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input outscalar${idx}_vld,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output Scalar to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_scalar_${idx}_aclk,"
	puts $fp "    input m_axis_scalar_${idx}_aresetn,"
	puts $fp "    output m_axis_scalar_${idx}_tlast,"
	puts $fp "    output m_axis_scalar_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] m_axis_scalar_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] m_axis_scalar_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\] m_axis_scalar_${idx}_tdata,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input m_axis_scalar_${idx}_tready,"
	} else {
	    puts $fp "    input m_axis_scalar_${idx}_tready"
	}
    }
    puts $fp ");"
    puts $fp ""
    puts $fp ""
    puts $fp "localparam C_MAX_INSCALARS = ${num};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] S_AXIS_SCALAR_BIT_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INSCALAR_${val}_BITS,"
    }
    puts $fp "C_INSCALAR_0_BITS};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] S_AXIS_SCALAR_IS_DIRECT_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_SCALAR_${val}_IS_DIRECT,"
    }
    puts $fp "S_AXIS_SCALAR_0_IS_DIRECT};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] S_AXIS_SCALAR_DMWIDTH_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_SCALAR_${val}_DIRECT_DMWIDTH,"
    }
    puts $fp "S_AXIS_SCALAR_0_DIRECT_DMWIDTH};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] S_AXIS_SCALAR_IS_ASYNC_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_SCALAR_${val}_DIRECT_IS_ASYNC,"
    }
    puts $fp "S_AXIS_SCALAR_0_DIRECT_IS_ASYNC};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] S_AXIS_SCALAR_DEPTH_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_SCALAR_${val}_DIRECT_DEPTH,"
    }
    puts $fp "S_AXIS_SCALAR_0_DIRECT_DEPTH};"
    puts $fp ""
    puts $fp "localparam C_MAX_OUTSCALARS = ${num};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] M_AXIS_SCALAR_BIT_ARRAY = {";
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTSCALAR_${val}_BITS,"
    }
    puts $fp "C_OUTSCALAR_0_BITS};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] M_AXIS_SCALAR_IS_DIRECT_ARRAY = {";
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_SCALAR_${val}_IS_DIRECT,"
    }
    puts $fp "M_AXIS_SCALAR_0_IS_DIRECT};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] M_AXIS_SCALAR_DMWIDTH_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_SCALAR_${val}_DIRECT_DMWIDTH,"
    }
    puts $fp "M_AXIS_SCALAR_0_DIRECT_DMWIDTH};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] M_AXIS_SCALAR_IS_ASYNC_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_SCALAR_${val}_DIRECT_IS_ASYNC,"
    }
    puts $fp "M_AXIS_SCALAR_0_DIRECT_IS_ASYNC};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] M_AXIS_SCALAR_DEPTH_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_SCALAR_${val}_DIRECT_DEPTH,"
    }
    puts $fp "M_AXIS_SCALAR_0_DIRECT_DEPTH};"
    puts $fp ""
    puts $fp "localparam C_MAX_SCALAR_BITS = 1024;"
    puts $fp ""
    puts $fp "reg \[31:0\] scalar_out_reg;  //output data register for control interface"
    puts $fp ""
    puts $fp "wire \[C_NUM_INSCALARS-1:0\] inscalar_we;                              //write enables for input scalars"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] inscalar_fifo \[0:C_NUM_INSCALARS-1\];    //input scalar data values from register to fifo"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] inscalar \[0:C_NUM_INSCALARS-1\];         //input scalar data values from fifo to ports"
    puts $fp "wire \[C_MAX_INSCALARS-1:0\] inscalar_ready;                           //input scalar ready to be buffered in fifo"
    puts $fp ""
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_re;                            //read enables for output scalars"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] outscalar \[0:C_NUM_OUTSCALARS-1\];       //output scalar data values from port into reg"
    puts $fp "reg  \[C_MAX_SCALAR_BITS-1:0\] outscalar_reg \[0:C_NUM_OUTSCALARS-1\];   //output scalar data values from reg into fifo"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] outscalar_fifo \[0:C_NUM_OUTSCALARS-1\];  //output scalar data values from fifo into 32bit interface"
    puts $fp "wire \[31:0\] outscalar_fifo32 \[0:C_NUM_OUTSCALARS-1\];                 //output scalar data values from fifo 32bit chunk (for reading)"
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_vld;                           //output scalar valid signals"
    puts $fp "reg \[C_NUM_OUTSCALARS-1:0\] outscalar_found_vld;                     //output scalar valid found signals"
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_read;                         //read signal from the out_register to the outscalar_fifo"
    puts $fp ""
    puts $fp "reg capture_reg;//register the capture signal to trigger the next cycle"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_clk;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_tlast;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_tvalid;"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] in_tkeep \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] in_tstrb \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_MAX_SCALAR_BITS-1:0\]   in_tdata \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_dwconv_tlast;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_SCALAR_BITS-1:0\] in_dwconv_tdata \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_dwconv_tready;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] in_dwconv_full;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_clk;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_tlast;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_tvalid;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_empty;"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] out_tkeep \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] out_tstrb \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_MAX_SCALAR_BITS-1:0\]   out_tdata \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_dwconv_tlast;"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_SCALAR_BITS-1:0\] out_dwconv_tdata \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_NUM_INSCALARS-1:0\] out_dwconv_tready;"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] out_dwconv_tstrb \[C_NUM_INSCALARS-1:0\];"
    puts $fp "    wire \[C_MAX_SCALAR_BITS/8-1:0\] out_dwconv_tkeep \[C_NUM_INSCALARS-1:0\];"
    puts $fp ""
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INSCALARS > ${idx} && S_AXIS_SCALAR_${idx}_IS_DIRECT == 1) begin"
	puts $fp "            assign in_clk\[${idx}\] = s_axis_scalar_${idx}_aclk;"
	puts $fp "            assign in_rst\[${idx}\] = s_axis_scalar_${idx}_aresetn;"
	puts $fp "            assign in_tlast\[${idx}\] = s_axis_scalar_${idx}_tlast;"
	puts $fp "            assign in_tvalid\[${idx}\] = s_axis_scalar_${idx}_tvalid;"
	puts $fp "            assign in_tkeep\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] = s_axis_scalar_${idx}_tkeep;"
	puts $fp "            assign in_tstrb\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] = s_axis_scalar_${idx}_tstrb;"
	puts $fp "            assign in_tdata\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\] = s_axis_scalar_${idx}_tdata;"
	puts $fp "            assign s_axis_scalar_${idx}_tready = in_tready\[${idx}\];"
	puts $fp "        end"
    }
    puts $fp ""
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTSCALARS > ${idx} && M_AXIS_SCALAR_${idx}_IS_DIRECT == 1) begin"
	puts $fp "            assign out_clk\[${idx}\] = m_axis_scalar_${idx}_aclk;"
	puts $fp "            assign out_rst\[${idx}\] = m_axis_scalar_${idx}_aresetn;"
	puts $fp "            assign m_axis_scalar_${idx}_tlast = out_dwconv_tlast\[${idx}\];"
	puts $fp "            assign m_axis_scalar_${idx}_tvalid = out_dwconv_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_scalar_${idx}_tkeep = out_dwconv_tkeep\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_scalar_${idx}_tstrb = out_dwconv_tstrb\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_scalar_${idx}_tdata = out_dwconv_tdata\[${idx}\]\[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\];"
	puts $fp "            assign out_dwconv_tready\[${idx}\] = m_axis_scalar_${idx}_tready;"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp ""
    puts $fp "always @(posedge acc_clk)"
    puts $fp "    capture_reg <= outscalar_capture;"
    puts $fp ""
    puts $fp "generate"
    puts $fp "    //map input scalar data values from register to ports"
    puts $fp "    if(C_NUM_INSCALARS > 0)"
    puts $fp "        assign inscalar0 = inscalar\[0\]\[C_INSCALAR_0_BITS-1:0\];"
    puts $fp "    else begin"
    puts $fp "        assign inscalar0 = 0;"
    puts $fp "        assign inscalar_fifo_empty = 0;"
    puts $fp "        assign inscalar_fifo_full = 0;"
    puts $fp "    end"
    puts $fp ""
    for {set idx 1} {$idx < $num} {incr idx} {
	puts $fp "    if(C_NUM_INSCALARS > ${idx})"
	puts $fp "        assign inscalar${idx} = inscalar\[${idx}\]\[C_INSCALAR_${idx}_BITS-1:0\];"
	puts $fp "    else"
	puts $fp "        assign inscalar${idx} = 0;"
	puts $fp ""
    }
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//map output scalar data values from ports to register"
    puts $fp "generate"
    puts $fp "    if(C_NUM_OUTSCALARS > 0) begin"
    puts $fp "        assign outscalar\[0\]\[C_OUTSCALAR_0_BITS-1:0\] = outscalar0;"
    puts $fp "        if(C_HAS_RETURN > 0)"
    puts $fp "            assign outscalar_vld\[0\] = outscalar_capture;"
    puts $fp "        else"
    puts $fp "            assign outscalar_vld\[0\] = outscalar0_vld;"
    puts $fp "    end"
    for {set idx 1} {$idx < $num} {incr idx} {
	puts $fp "    if(C_NUM_OUTSCALARS > ${idx}) begin"
	puts $fp "        assign outscalar\[${idx}\]\[C_OUTSCALAR_${idx}_BITS-1:0\] = outscalar${idx};"
	puts $fp "        assign outscalar_vld\[${idx}\] = outscalar${idx}_vld;"
	puts $fp "    end"
    }
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//assign output data reg to port"
    puts $fp "assign scalar_dout = scalar_out_reg;"
    puts $fp ""
    puts $fp "//generate input scalar registers"
    puts $fp "genvar idx;"
    puts $fp "generate"
    puts $fp "    for(idx=0; idx<C_NUM_INSCALARS; idx=idx+1) begin :INSCALAR_REG_GEN"
    puts $fp "        if(S_AXIS_SCALAR_IS_DIRECT_ARRAY\[32*(idx+1)-1:32*idx\] == 0) begin"
    puts $fp "            //regular in_register to fifo"
    puts $fp "            assign inscalar_we\[idx\] = scalar_we & (scalar_write_addr == idx);"
    puts $fp "            in_register #("
    puts $fp "                .C_NUM_BITS(S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) inscalar_reg ("
    puts $fp "                .din(scalar_din),"
    puts $fp "                .we(inscalar_we\[idx\]),"
    puts $fp "                .clk(clk),"
    puts $fp "                .dout(inscalar_fifo\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .ready(inscalar_ready\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            fifo #("
    puts $fp "                .WIDTH(S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .DEPTH(C_FIFO_DEPTH)"
    puts $fp "            ) in_fifo_i ("
    puts $fp "                .wr_clk(clk),"
    puts $fp "                .din(inscalar_fifo\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .write(inscalar_ready\[idx\]),"
    puts $fp "                .full(inscalar_fifo_full\[idx\]),"
    puts $fp "                .dout(inscalar\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .read(inscalar_next\[idx\]),"
    puts $fp "                .empty(inscalar_fifo_empty\[idx\]),"
    puts $fp "                .rd_clk(acc_clk),"
    puts $fp "                .rst(0) "
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "        else begin"
    puts $fp "            //input AXI Stream to fifo"
    puts $fp "            if(S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(in_clk\[idx\]),"
    puts $fp "                    .aresetn(in_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(in_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(in_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(in_tdata\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(in_tstrb\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(in_tkeep\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(in_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(in_dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(in_dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(in_dwconv_tdata\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(in_dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width conversion, wire the input signals straight through"
    puts $fp "                assign in_dwconv_tlast\[idx\] = in_tlast\[idx\];"
    puts $fp "                assign in_dwconv_tvalid\[idx\] = in_tvalid\[idx\];"
    puts $fp "                assign in_tready\[idx\] = in_dwconv_tready\[idx\];   //output"
    puts $fp "                assign in_dwconv_tdata\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = in_tdata\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            assign in_dwconv_tready\[idx\] = ~in_dwconv_full\[idx\];"
    puts $fp "            fifo #("
    puts $fp "                .WIDTH(S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .DEPTH(S_AXIS_SCALAR_DEPTH_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) in_fifo_i ("
    puts $fp "                .wr_clk(in_clk\[idx\]),"
    puts $fp "                .din(in_dwconv_tdata\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .write(in_dwconv_tvalid\[idx\]),"
    puts $fp "                .full(in_dwconv_full\[idx\]),"
    puts $fp "                .dout(inscalar\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .read(inscalar_next\[idx\]),"
    puts $fp "                .empty(inscalar_fifo_empty\[idx\]),"
    puts $fp "                .rd_clk(acc_clk),"
    puts $fp "                .rst(0) "    
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    end"
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//generate output scalar registers"
    puts $fp "generate"
    puts $fp "    if(C_NUM_OUTSCALARS == 0) begin"
    puts $fp "        assign outscalar_fifo32\[0\] = 0;"
    puts $fp "        assign outscalar_fifo32\[-1\] = 0;"
    puts $fp ""
    puts $fp "        assign outscalar_fifo_empty = 0;"
    puts $fp "        assign outscalar_fifo_full = 0;"
    puts $fp "        assign outscalar_null_empty = 0;"
    puts $fp "        assign outscalar_null_dout = 0;"
    puts $fp "    end"
    puts $fp ""
    puts $fp "    for(idx=0; idx<C_NUM_OUTSCALARS; idx=idx+1) begin :OUTSCALAR_REG_GEN"
    puts $fp "        //generate valid latch"
    puts $fp "        always @(posedge acc_clk) begin"
    puts $fp "            if(outscalar_vld\[idx\]) begin"
    puts $fp "                outscalar_reg\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] <= outscalar\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                outscalar_found_vld\[idx\] <= 1;"
    puts $fp "            end"
    puts $fp "            if(capture_reg)"
    puts $fp "                outscalar_found_vld\[idx\] <= 0;"
    puts $fp "        end"
    puts $fp ""
    puts $fp "        if(M_AXIS_SCALAR_IS_DIRECT_ARRAY\[32*(idx+1)-1:32*idx\] == 0) begin"
    puts $fp "            assign outscalar_re\[idx\] = scalar_re & (scalar_read_addr == (idx+C_MAX_INSCALARS));"
    puts $fp "            //regular fifo to out_register"
    puts $fp "            fifo #("
    puts $fp "                .WIDTH(M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .DEPTH(C_FIFO_DEPTH)"
    puts $fp "            ) out_fifo_i ("
    puts $fp "                .wr_clk(acc_clk),"
    puts $fp "                .din(outscalar_reg\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .write(capture_reg & outscalar_found_vld\[idx\]),"
    puts $fp "                .full(outscalar_fifo_full\[idx\]),"
    puts $fp "                .dout(outscalar_fifo\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .read(outscalar_read\[idx\]),"
    puts $fp "                .empty(outscalar_fifo_empty\[idx\]),"
    puts $fp "                .rd_clk(clk),"
    puts $fp "                .rst(0) "
    puts $fp "            );"
    puts $fp ""
    puts $fp "            fifo #("
    puts $fp "                .WIDTH(1),"
    puts $fp "                .DEPTH(C_FIFO_DEPTH)"
    puts $fp "            ) null_fifo_i ("
    puts $fp "                .wr_clk(acc_clk),"
    puts $fp "                .din(outscalar_found_vld\[idx\]),"
    puts $fp "                .write(capture_reg),"
    puts $fp "                //.full(outscalar_fifo_full\[idx\]),"
    puts $fp "                .dout(outscalar_null_dout\[idx\]),"
    puts $fp "                .read(outscalar_null_read\[idx\]),"
    puts $fp "                .empty(outscalar_null_empty\[idx\]),"
    puts $fp "                .rd_clk(clk), "
    puts $fp "                .rst(0) "    
    puts $fp "            );"
    puts $fp ""
    puts $fp "            out_register #("
    puts $fp "                .C_NUM_BITS(M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) outscalar_reg_i ("
    puts $fp "                .din(outscalar_fifo\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .read(outscalar_read\[idx\]),"
    puts $fp "                .clk(clk),"
    puts $fp "                .re(outscalar_re\[idx\]),"
    puts $fp "                .dout(outscalar_fifo32\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "        else begin"
    puts $fp "            fifo #("
    puts $fp "                .WIDTH(M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .DEPTH(M_AXIS_SCALAR_DEPTH_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) out_fifo_i ("
    puts $fp "                .wr_clk(acc_clk),"
    puts $fp "                .din(outscalar_reg\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .write(capture_reg & outscalar_found_vld\[idx\]),"
    puts $fp "                .full(outscalar_fifo_full\[idx\]),"
    puts $fp "                .dout(out_tdata\[idx\]\[M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .read(out_tready\[idx\]),"
    puts $fp "                .empty(out_empty\[idx\]),"
    puts $fp "                .rd_clk(out_clk\[idx\]),"
    puts $fp "                .rst(0) "    
    puts $fp "            );"
    puts $fp ""
    puts $fp "            assign out_tvalid\[idx\] = ~out_empty\[idx\];"
    puts $fp "            if(M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                assign out_tstrb\[idx\]\[M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign out_tkeep\[idx\]\[M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(M_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(out_clk\[idx\]),"
    puts $fp "                    .aresetn(out_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(out_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(out_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(out_tdata\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(out_tstrb\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(out_tkeep\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(out_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(out_dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(out_dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(out_dwconv_tdata\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(out_dwconv_tstrb\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(out_dwconv_tkeep\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(out_dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width conversion, wire the input signals straight through"
    puts $fp "                assign out_dwconv_tlast\[idx\] = out_tlast\[idx\];"
    puts $fp "                assign out_dwconv_tvalid\[idx\] = out_tvalid\[idx\];"
    puts $fp "                assign out_tready\[idx\] = out_dwconv_tready\[idx\];   //output"
    puts $fp "                assign out_dwconv_tdata\[idx\]\[S_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = out_tdata\[idx\]\[S_AXIS_SCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign out_dwconv_tstrb\[idx\]\[M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign out_dwconv_tkeep\[idx\]\[M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {M_AXIS_SCALAR_DMWIDTH_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "            end"
    puts $fp "        end"
    puts $fp ""
    puts $fp "    end"
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "    //read interface"
    puts $fp "    always @* begin"
    puts $fp "        if(scalar_read_addr >= C_MAX_INSCALARS)"
    puts $fp "            scalar_out_reg <= outscalar_fifo32\[scalar_read_addr-C_MAX_INSCALARS\];"
    puts $fp "        else"
    puts $fp "            scalar_out_reg <= 32'h00C0FFEE;"
    puts $fp "    end"
    puts $fp ""
    puts $fp "endmodule"

    close $fp
}

proc gen_infifo {num} {
    if {[file exists "hdl/in_fifo_args.v"]} {
	file delete -force "hdl/in_fifo_args.v"
    }
    set fp [open "hdl/in_fifo_args.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module in_fifo_args #("
    puts $fp "    parameter C_NUM_INPUT_FIFOs = 0,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_WIDTH = 8,     //width of input fifo interface on the accelerator, actual"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_DEPTH = 16,      //depth of FIFO in adapter for input fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input fifo interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_BYTE_WIDTH = 8,     //width of input fifo interface on the accelerator, padded"
	} else {
	    puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_BYTE_WIDTH = 8     //width of input fifo interface on the accelerator, padded"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input in_fifo_allow,"
    puts $fp "    output \[C_NUM_INPUT_FIFOs-1:0\] in_fifo_ready,"
    puts $fp "    output \[C_NUM_INPUT_FIFOs-1:0\] in_fifo_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_fifo_${idx}_aclk,"
	puts $fp "    input s_axis_fifo_${idx}_aresetn,"
	puts $fp "    input s_axis_fifo_${idx}_tlast,"
	puts $fp "    input s_axis_fifo_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH-1:0\] s_axis_fifo_${idx}_tdata,"
	puts $fp "    output s_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_iarg_${idx}_empty_n,"
	puts $fp "    output \[S_AXIS_FIFO_${idx}_WIDTH-1:0\] ap_fifo_iarg_${idx}_dout,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_fifo_iarg_${idx}_read,"
	} else {
	    puts $fp "    input ap_fifo_iarg_${idx}_read"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "// function called round8 rounds value upto next power of 8 if needed"
    puts $fp "function integer round8 (input integer val);"
    puts $fp "begin"
    puts $fp "    for(round8=0; round8<val; round8=round8+8)"
    puts $fp "        round8=round8;"
    puts $fp "    end"
    puts $fp "endfunction"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX_INPUT_FIFOs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_INFIFO_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_FIFO_${val}_BYTE_WIDTH,"
	} else {
	    puts $fp "S_AXIS_FIFO_${val}_BYTE_WIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_INFIFO_REAL_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_FIFO_${val}_WIDTH,"
	} else {
	    puts $fp "S_AXIS_FIFO_${val}_WIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_FIFO_${val}_DEPTH,"
	} else {
	    puts $fp "S_AXIS_FIFO_${val}_DEPTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_FIFO_${val}_DMWIDTH,"
	} else {
	    puts $fp "S_AXIS_FIFO_${val}_DMWIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_IS_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_FIFO_${val}_IS_ASYNC,"
	} else {
	    puts $fp "S_AXIS_FIFO_${val}_IS_ASYNC\};"
	}
    }
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] axis_clk;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] axis_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] trunc_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] trunc_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] trunc_tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] trunc_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] read;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] empty;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INPUT_FIFOs > ${idx}) begin"
	puts $fp "            assign axis_clk\[${idx}\] = s_axis_fifo_${idx}_aclk;"
	puts $fp "            assign axis_rst\[${idx}\] = s_axis_fifo_${idx}_aresetn;"
	puts $fp "            assign tlast\[${idx}\] = s_axis_fifo_${idx}_tlast;"
	puts $fp "            assign tvalid\[${idx}\] = s_axis_fifo_${idx}_tvalid;"
	puts $fp "            assign read\[${idx}\] = ap_fifo_iarg_${idx}_read;"
	puts $fp "            assign tkeep\[${idx}\]\[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] = s_axis_fifo_${idx}_tkeep;"
	puts $fp "            assign tstrb\[${idx}\]\[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] = s_axis_fifo_${idx}_tstrb;"
	puts $fp "            assign tdata\[${idx}\]\[S_AXIS_FIFO_${idx}_DMWIDTH-1:0\] = s_axis_fifo_${idx}_tdata;"
	puts $fp "            assign s_axis_fifo_${idx}_tready = tready\[${idx}\];"
	puts $fp "            assign ap_fifo_iarg_${idx}_empty_n = empty\[${idx}\];"
	puts $fp "            assign ap_fifo_iarg_${idx}_dout = dout\[${idx}\]\[S_AXIS_FIFO_${idx}_BYTE_WIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_INPUT_FIFOs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(axis_clk\[idx\]),"
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width conversion, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = tvalid\[idx\];"
    puts $fp "                assign tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                //use truncator"
    puts $fp "                axisTrunc #("
    puts $fp "                    .IN_WIDTH(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .OUT_WIDTH(C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_trunc_i ("
    puts $fp "                    .IN_TLAST(dwconv_tlast\[idx\]),"
    puts $fp "                    .IN_TVALID(dwconv_tvalid\[idx\]),"
    puts $fp "                    .IN_TDATA(dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .IN_TREADY(dwconv_tready\[idx\]),"
    puts $fp "                    .OUT_TLAST(trunc_tlast\[idx\]),"
    puts $fp "                    .OUT_TVALID(trunc_tvalid\[idx\]),"
    puts $fp "                    .OUT_TDATA(trunc_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .OUT_TREADY(trunc_tready\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign trunc_tlast\[idx\] = dwconv_tlast\[idx\];"
    puts $fp "                assign trunc_tvalid\[idx\] = dwconv_tvalid\[idx\];"
    puts $fp "                assign dwconv_tready\[idx\] = trunc_tready\[idx\];   //output"
    puts $fp "                assign trunc_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\] > 0) begin"
    puts $fp "                //use fifo"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_IS_ASYNC(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo_i ("
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .inclk(axis_clk\[idx\]),"
    puts $fp "                    .in_tdata(trunc_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(trunc_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(trunc_tvalid\[idx\]),"
    puts $fp "                    .in_tready(trunc_tready\[idx\]),"
    puts $fp "                    .outclk(acc_clk), "
    puts $fp "                    .out_tdata(buf_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign buf_tlast\[idx\] = trunc_tlast\[idx\];"
    puts $fp "                assign buf_tvalid\[idx\] = trunc_tvalid\[idx\];"
    puts $fp "                assign trunc_tready\[idx\] = buf_tready\[idx\];   //output"
    puts $fp "                assign buf_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = trunc_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            axis2fifo #( "
    puts $fp "                .DATA_WIDTH(C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis2fifo_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ALLOW(in_fifo_allow),"
    puts $fp "                .CTRL_READY(in_fifo_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(in_fifo_finished\[idx\]),"
    puts $fp "                .AXIS_TLAST(buf_tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(buf_tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(buf_tdata\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(buf_tready\[idx\]),"
    puts $fp "                .FIFO_EMPTY(empty\[idx\]),"
    puts $fp "                .FIFO_DOUT(dout\[idx\]\[C_INFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .FIFO_READ(read\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_outfifo {num} {
    if {[file exists "hdl/out_fifo_args.v"]} {
	file delete -force "hdl/out_fifo_args.v"
    }
    set fp [open "hdl/out_fifo_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module out_fifo_args #("
    puts $fp "    parameter C_NUM_OUTPUT_FIFOs = 0,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_WIDTH = 8,     //width of input fifo interface on the accelerator, actual"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_DEPTH = 16,     //depth of FIFO in adapter for output fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_DMWIDTH = 8,  //width of AXIS interface from DM to adapter for output fifo interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_BYTE_WIDTH = 8,     //width of input fifo interface on the accelerator, padded"
	} else {
	    puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_BYTE_WIDTH = 8     //width of input fifo interface on the accelerator, padded"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk," 
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input out_fifo_allow,"
    puts $fp "    output \[C_NUM_OUTPUT_FIFOs-1:0\] out_fifo_ready,"
    puts $fp "    output \[C_NUM_OUTPUT_FIFOs-1:0\] out_fifo_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output FIFO to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_fifo_${idx}_aclk,"
	puts $fp "    input m_axis_fifo_${idx}_aresetn,"
	puts $fp "    output m_axis_fifo_${idx}_tlast,"
	puts $fp "    output m_axis_fifo_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH-1:0\] m_axis_fifo_${idx}_tdata,"
	puts $fp "    input m_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_oarg_${idx}_full_n,"
	puts $fp "    input \[M_AXIS_FIFO_${idx}_WIDTH-1:0\] ap_fifo_oarg_${idx}_din,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_fifo_oarg_${idx}_write,"
	} else {
	    puts $fp "    input ap_fifo_oarg_${idx}_write"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "// function called round8 rounds value upto next power of 8 if needed"
    puts $fp "function integer round8 (input integer val);"
    puts $fp "begin"
    puts $fp "    for(round8=0; round8<val; round8=round8+8)"
    puts $fp "        round8=round8;"
    puts $fp "    end"
    puts $fp "endfunction"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX_OUTPUT_FIFOs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_OUTFIFO_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_FIFO_${val}_BYTE_WIDTH,"
    }
    puts $fp "M_AXIS_FIFO_0_BYTE_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_OUTFIFO_REAL_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_FIFO_${val}_WIDTH,"
    }
    puts $fp "M_AXIS_FIFO_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_FIFO_${val}_DEPTH,"
    }
    puts $fp "M_AXIS_FIFO_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_FIFO_${val}_DMWIDTH,"
    }
    puts $fp "M_AXIS_FIFO_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_IS_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_FIFO_${val}_IS_ASYNC,"
    }
    puts $fp "M_AXIS_FIFO_0_IS_ASYNC\};"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] axis_clk;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] axis_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] pad_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] pad_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] pad_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] pad_tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tkeep \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tstrb \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] write;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] full;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "        "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTPUT_FIFOs > ${idx}) begin"
	puts $fp "            assign axis_clk\[${idx}\] = m_axis_fifo_${idx}_aclk;"
	puts $fp "            assign axis_rst\[${idx}\] = m_axis_fifo_${idx}_aresetn;"
	puts $fp "            assign dwconv_tready\[${idx}\] = m_axis_fifo_${idx}_tready;"
	puts $fp "            assign m_axis_fifo_${idx}_tlast = dwconv_tlast\[${idx}\];"
	puts $fp "            assign m_axis_fifo_${idx}_tvalid = dwconv_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_fifo_${idx}_tkeep = dwconv_tkeep\[${idx}\]\[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_fifo_${idx}_tstrb = dwconv_tstrb\[${idx}\]\[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_fifo_${idx}_tdata = dwconv_tdata\[${idx}\]\[M_AXIS_FIFO_${idx}_DMWIDTH-1:0\];"
	puts $fp "            assign ap_fifo_oarg_${idx}_full_n = full\[${idx}\];"
	puts $fp "            assign write\[${idx}\] = ap_fifo_oarg_${idx}_write;"
	puts $fp "            assign din\[${idx}\]\[M_AXIS_FIFO_${idx}_BYTE_WIDTH-1:0\] = ap_fifo_oarg_${idx}_din;"
	puts $fp "            assign tkeep\[${idx}\] = {M_AXIS_FIFO_${idx}_BYTE_WIDTH/8{1'b1}};"
	puts $fp "            assign tstrb\[${idx}\] = {M_AXIS_FIFO_${idx}_BYTE_WIDTH/8{1'b1}};"
	puts $fp "        end"
    }
    puts $fp "    endgenerate    "
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_OUTPUT_FIFOs; idx=idx+1) begin: OUT_FIFO_GEN"
    puts $fp "            fifo2axis #( "
    puts $fp "                .DATA_WIDTH(C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) fifo2axis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ALLOW(out_fifo_allow),"
    puts $fp "                .CTRL_READY(out_fifo_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(out_fifo_finished\[idx\]),"
    puts $fp "                .AXIS_TLAST(tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(tdata\[idx\]\[C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(tready\[idx\]),"
    puts $fp "                .FIFO_FULL(full\[idx\]),"
    puts $fp "                .FIFO_DIN(din\[idx\]\[C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .FIFO_WRITE(write\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            if(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\] > 0) begin"
    puts $fp "                //use fifo"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_IS_ASYNC(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo_i ("
    puts $fp "                    .aresetn(acc_aresetn),"
    puts $fp "                    .inclk(acc_clk),"
    puts $fp "                    .in_tdata(tdata\[idx\]\[C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(tvalid\[idx\]),"
    puts $fp "                    .in_tready(tready\[idx\]),"
    puts $fp "                    .outclk(axis_clk\[idx\]), "
    puts $fp "                    .out_tdata(buf_tdata\[idx\]\[C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign buf_tlast\[idx\] = tlast\[idx\];"
    puts $fp "                assign buf_tvalid\[idx\] = tvalid\[idx\];"
    puts $fp "                assign tready\[idx\] = buf_tready\[idx\];   //output"
    puts $fp "                assign buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if(C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\] != C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                //use padder"
    puts $fp "                axisPad #("
    puts $fp "                    .IN_WIDTH(C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .OUT_WIDTH(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_trunc_i ("
    puts $fp "                    .IN_TLAST(buf_tlast\[idx\]),"
    puts $fp "                    .IN_TVALID(buf_tvalid\[idx\]),"
    puts $fp "                    .IN_TDATA(buf_tdata\[idx\]\[C_OUTFIFO_REAL_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .IN_TREADY(buf_tready\[idx\]),"
    puts $fp "                    .OUT_TLAST(pad_tlast\[idx\]),"
    puts $fp "                    .OUT_TVALID(pad_tvalid\[idx\]),"
    puts $fp "                    .OUT_TDATA(pad_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .OUT_TREADY(pad_tready\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign pad_tlast\[idx\] = buf_tlast\[idx\];"
    puts $fp "                assign pad_tvalid\[idx\] = buf_tvalid\[idx\];"
    puts $fp "                assign buf_tready\[idx\] = pad_tready\[idx\];   //output"
    puts $fp "                assign pad_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(axis_clk\[idx\]),"
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(pad_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(pad_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(pad_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(pad_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(dwconv_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(dwconv_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width converter, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = buf_tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = buf_tvalid\[idx\];"
    puts $fp "                assign buf_tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = tstrb\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "                assign dwconv_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = tkeep\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "            end"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"

    close $fp
}

proc gen_inaxis {num} {
    if {[file exists "hdl/in_axis_args.v"]} {
	file delete -force "hdl/in_axis_args.v"
    }
    set fp [open "hdl/in_axis_args.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module in_axis_args #("
    puts $fp "    parameter C_NUM_INPUT_AXISs = 0,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_WIDTH = 8,     //width of input axis interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_DEPTH = 16,      //depth of AXIS in adapter for input axis interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input axis interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_IS_ASYNC = 0,   //should fifo buffer be asynchronous (0) or synchronours (1)"
	} else {
	    puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_IS_ASYNC = 0   //should fifo buffer be asynchronous (0) or synchronours (1)"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input in_axis_allow,"
    puts $fp "    output \[C_NUM_INPUT_AXISs-1:0\] in_axis_ready,"
    puts $fp "    output \[C_NUM_INPUT_AXISs-1:0\] in_axis_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream pass-through interface ${idx}"
	puts $fp "    input s_axis_iarg_${idx}_aclk,"
	puts $fp "    input s_axis_iarg_${idx}_aresetn,"
	puts $fp "    input s_axis_iarg_${idx}_tlast,"
	puts $fp "    input s_axis_iarg_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] s_axis_iarg_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] s_axis_iarg_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH-1:0\] s_axis_iarg_${idx}_tdata,"
	puts $fp "    output s_axis_iarg_${idx}_tready,"
	puts $fp "    output ap_axis_iarg_${idx}_tlast,"
	puts $fp "    output ap_axis_iarg_${idx}_tvalid,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH/8-1:0\] ap_axis_iarg_${idx}_tkeep,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH/8-1:0\] ap_axis_iarg_${idx}_tstrb,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH-1:0\] ap_axis_iarg_${idx}_tdata,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_axis_iarg_${idx}_tready,"
	} else {
	    puts $fp "    input ap_axis_iarg_${idx}_tready"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX_INPUT_AXISs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_AXISs*32)-1:0\] C_INAXIS_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_IARG_${val}_WIDTH,"
	} else {
	    puts $fp "S_AXIS_IARG_${val}_WIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_AXISs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_IARG_${val}_DEPTH,"
	} else {
	    puts $fp "S_AXIS_IARG_${val}_DEPTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_AXISs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_IARG_${val}_DMWIDTH,"
	} else {
	    puts $fp "S_AXIS_IARG_${val}_DMWIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_AXISs*32)-1:0\] C_IS_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "S_AXIS_IARG_${val}_IS_ASYNC,"
	} else {
	    puts $fp "S_AXIS_IARG_${val}_IS_ASYNC\};"
	}
    }
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] axis_clk;"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] axis_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dm_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dm_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dm_tkeep \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dm_tstrb \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   dm_tdata \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dm_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] dwconv_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] buf_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] ap_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] ap_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] ap_tkeep \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] ap_tstrb \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   ap_tdata \[C_NUM_INPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_AXISs-1:0\] ap_tready;"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INPUT_AXISs > ${idx}) begin"
	puts $fp "            assign axis_clk\[${idx}\] = s_axis_iarg_${idx}_aclk;"
	puts $fp "            assign axis_rst\[${idx}\] = s_axis_iarg_${idx}_aresetn;"
	puts $fp "            assign dm_tlast\[${idx}\] = s_axis_iarg_${idx}_tlast;"
	puts $fp "            assign dm_tvalid\[${idx}\] = s_axis_iarg_${idx}_tvalid;"
	puts $fp "            assign dm_tkeep\[${idx}\]\[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] = s_axis_iarg_${idx}_tkeep;"
	puts $fp "            assign dm_tstrb\[${idx}\]\[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] = s_axis_iarg_${idx}_tstrb;"
	puts $fp "            assign dm_tdata\[${idx}\]\[S_AXIS_IARG_${idx}_DMWIDTH-1:0\] = s_axis_iarg_${idx}_tdata;"
	puts $fp "            assign s_axis_iarg_${idx}_tready = dm_tready\[${idx}\];"
	puts $fp "            assign ap_axis_iarg_${idx}_tlast = ap_tlast\[${idx}\];"
	puts $fp "            assign ap_axis_iarg_${idx}_tvalid = ap_tvalid\[${idx}\];"
	puts $fp "            assign ap_axis_iarg_${idx}_tkeep = ap_tkeep\[${idx}\]\[S_AXIS_IARG_${idx}_WIDTH/8-1:0\];"
	puts $fp "            assign ap_axis_iarg_${idx}_tstrb = ap_tstrb\[${idx}\]\[S_AXIS_IARG_${idx}_WIDTH/8-1:0\];"
	puts $fp "            assign ap_axis_iarg_${idx}_tdata = ap_tdata\[${idx}\]\[S_AXIS_IARG_${idx}_WIDTH-1:0\];"
	puts $fp "            assign ap_tready\[${idx}\] = ap_axis_iarg_${idx}_tready;"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the axis2axis modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_INPUT_AXISs; idx=idx+1) begin: IN_AXIS_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(axis_clk\[idx\]),"
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(dm_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(dm_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(dm_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(dm_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(dm_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(dm_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = dm_tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = dm_tvalid\[idx\];"
    puts $fp "                assign dm_tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dm_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\] > 0) begin"
    puts $fp "                //use fifo"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_IS_ASYNC(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo_i ("
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .inclk(axis_clk\[idx\]),"
    puts $fp "                    .in_tdata(dwconv_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(dwconv_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .in_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .outclk(acc_clk), "
    puts $fp "                    .out_tdata(buf_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign buf_tlast\[idx\] = dwconv_tlast\[idx\];"
    puts $fp "                assign buf_tvalid\[idx\] = dwconv_tvalid\[idx\];"
    puts $fp "                assign dwconv_tready\[idx\] = buf_tready\[idx\];   //output"
    puts $fp "                assign buf_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dwconv_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            inaxis #( "
    puts $fp "                .DATA_WIDTH(C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) inaxis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ALLOW(in_axis_allow),"
    puts $fp "                .CTRL_READY(in_axis_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(in_axis_finished\[idx\]),"
    puts $fp "                .DM_TLAST(buf_tlast\[idx\]),"
    puts $fp "                .DM_TVALID(buf_tvalid\[idx\]),"
    puts $fp "                .DM_TDATA(buf_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .DM_TREADY(buf_tready\[idx\]),"
    puts $fp "                .AP_TLAST(ap_tlast\[idx\]),"
    puts $fp "                .AP_TVALID(ap_tvalid\[idx\]),"
    puts $fp "                .AP_TDATA(ap_tdata\[idx\]\[C_INAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AP_TREADY(ap_tready\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_outaxis {num} {
    if {[file exists "hdl/out_axis_args.v"]} {
	file delete -force "hdl/out_axis_args.v"
    }
    set fp [open "hdl/out_axis_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module out_axis_args #("
    puts $fp "    parameter C_NUM_OUTPUT_AXISs = 0,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_WIDTH = 8,    //width of output axis interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_DEPTH = 16,     //depth of FIFO in adapter for output axis interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_DMWIDTH = 8,  //width of AXIS interface from DM to adapter for output axis interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_GEN_TLAST = 0,  //generate TLAST signal"
	} else {
	    puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_GEN_TLAST = 0  //generate TLAST signal"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input out_axis_allow,"
    puts $fp "    output \[C_NUM_OUTPUT_AXISs-1:0\] out_axis_ready,"
    puts $fp "    output \[C_NUM_OUTPUT_AXISs-1:0\] out_axis_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output AXIS to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_oarg_${idx}_aclk,"
	puts $fp "    input m_axis_oarg_${idx}_aresetn,"
	puts $fp "    output m_axis_oarg_${idx}_tlast,"
	puts $fp "    output m_axis_oarg_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\] m_axis_oarg_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\] m_axis_oarg_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH-1:0\] m_axis_oarg_${idx}_tdata,"
	puts $fp "    input m_axis_oarg_${idx}_tready,"
	puts $fp "    input ap_axis_oarg_${idx}_tlast,"
	puts $fp "    input ap_axis_oarg_${idx}_tvalid,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH/8-1:0\] ap_axis_oarg_${idx}_tkeep,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH/8-1:0\] ap_axis_oarg_${idx}_tstrb,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH-1:0\] ap_axis_oarg_${idx}_tdata,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    output ap_axis_oarg_${idx}_tready,"
	} else {
	    puts $fp "    output ap_axis_oarg_${idx}_tready"
	}
    }
    puts $fp "    );"
    puts $fp ""
    puts $fp ""
    puts $fp "    localparam C_MAX_OUTPUT_AXISs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_AXISs*32)-1:0\] C_OUTAXIS_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_OARG_${val}_WIDTH,"
    }
    puts $fp "M_AXIS_OARG_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_AXISs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_OARG_${val}_DEPTH,"
    }
    puts $fp "M_AXIS_OARG_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_AXISs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_OARG_${val}_DMWIDTH,"
    }
    puts $fp "M_AXIS_OARG_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_AXISs*32)-1:0\] C_IS_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_OARG_${val}_IS_ASYNC,"
    }
    puts $fp "M_AXIS_OARG_0_IS_ASYNC\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_AXISs*32)-1:0\] C_GEN_TLAST_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_OARG_${val}_GEN_TLAST,"
    }
    puts $fp "M_AXIS_OARG_0_GEN_TLAST\};"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] axis_clk;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] axis_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dm_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dm_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dm_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dm_tkeep \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dm_tstrb \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dm_tdata \[C_MAX_OUTPUT_AXISs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] buf_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_MAX_OUTPUT_AXISs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] dwconv_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tkeep \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tstrb \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_MAX_OUTPUT_AXISs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] ap_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] ap_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_AXISs-1:0\] ap_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] ap_tkeep \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] ap_tstrb \[C_NUM_OUTPUT_AXISs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] ap_tdata \[C_MAX_OUTPUT_AXISs-1:0\];"
    puts $fp "        "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTPUT_AXISs > ${idx}) begin"
	puts $fp "            assign axis_clk\[${idx}\] = m_axis_oarg_${idx}_aclk;"
	puts $fp "            assign axis_rst\[${idx}\] = m_axis_oarg_${idx}_aresetn;"
	puts $fp "            assign dm_tready\[${idx}\] = m_axis_oarg_${idx}_tready;"
	puts $fp "            assign m_axis_oarg_${idx}_tlast = dm_tlast\[${idx}\];"
	puts $fp "            assign m_axis_oarg_${idx}_tvalid = dm_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_oarg_${idx}_tkeep = dm_tkeep\[${idx}\]\[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_oarg_${idx}_tstrb = dm_tstrb\[${idx}\]\[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_oarg_${idx}_tdata = dm_tdata\[${idx}\]\[M_AXIS_OARG_${idx}_DMWIDTH-1:0\];"
	puts $fp "            assign ap_axis_oarg_${idx}_tready = ap_tready\[${idx}\];"
	puts $fp "            assign ap_tlast\[${idx}\] = ap_axis_oarg_${idx}_tlast;"
	puts $fp "            assign ap_tvalid\[${idx}\] = ap_axis_oarg_${idx}_tvalid;"
	puts $fp "            assign ap_tdata\[${idx}\]\[M_AXIS_OARG_${idx}_WIDTH-1:0\] = ap_axis_oarg_${idx}_tdata;"
	puts $fp "            assign ap_tkeep\[${idx}\] = {M_AXIS_OARG_${idx}_WIDTH/8{1'b1}};"
	puts $fp "            assign ap_tstrb\[${idx}\] = {M_AXIS_OARG_${idx}_WIDTH/8{1'b1}};"
	puts $fp "        end"
    }
    puts $fp "    endgenerate    "
    puts $fp "    "
    puts $fp "    //instantiate the axis2axis modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_OUTPUT_AXISs; idx=idx+1) begin: OUT_AXIS_GEN"
    puts $fp "            outaxis #( "
    puts $fp "                .DATA_WIDTH(C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .GEN_TLAST(C_GEN_TLAST_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) outaxis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ALLOW(out_axis_allow),"
    puts $fp "                .CTRL_READY(out_axis_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(out_axis_finished\[idx\]),"
    puts $fp "                .DM_TLAST(buf_tlast\[idx\]),"
    puts $fp "                .DM_TVALID(buf_tvalid\[idx\]),"
    puts $fp "                .DM_TDATA(buf_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .DM_TREADY(buf_tready\[idx\]),"
    puts $fp "                .AP_TLAST(ap_tlast\[idx\]),"
    puts $fp "                .AP_TVALID(ap_tvalid\[idx\]),"
    puts $fp "                .AP_TDATA(ap_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AP_TREADY(ap_tready\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            if(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\] > 0) begin"
    puts $fp "                //use fifo"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_IS_ASYNC(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo_i ("
    puts $fp "                    .aresetn(acc_aresetn),"
    puts $fp "                    .inclk(acc_clk),"
    puts $fp "                    .in_tdata(buf_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(buf_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                    .in_tready(buf_tready\[idx\]),"
    puts $fp "                    .outclk(axis_clk\[idx\]), "
    puts $fp "                    .out_tdata(dwconv_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .out_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(dwconv_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = buf_tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = buf_tvalid\[idx\];"
    puts $fp "                assign buf_tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(axis_clk\[idx\]),"
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(dwconv_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(ap_tstrb\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(ap_tkeep\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(dwconv_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dm_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dm_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dm_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(dm_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(dm_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(dm_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width converter, wire the input signals straight through"
    puts $fp "                assign dm_tlast\[idx\] = dwconv_tlast\[idx\];"
    puts $fp "                assign dm_tvalid\[idx\] = dwconv_tvalid\[idx\];"
    puts $fp "                assign dwconv_tready\[idx\] = dm_tready\[idx\];   //output"
    puts $fp "                assign dm_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dwconv_tdata\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dm_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = ap_tstrb\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "                assign dm_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = ap_tkeep\[idx\]\[C_OUTAXIS_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "            end"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"

    close $fp
}

proc gen_inbram {num num_ports} {
    if {[file exists "hdl/in_bram_args.v"]} {
	file delete -force "hdl/in_bram_args.v"
    }
    set fp [open "hdl/in_bram_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module in_bram_args #("
    puts $fp "    parameter C_NUM_INPUT_BRAMs = 0, "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter S_AXIS_BRAM_${idx}_PORTS = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_WIDTH = 8,     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_DEPTH = 2,      //depth of BRAM in adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_IS_ASYNC = 0,   //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAMIO_${idx}_DMWIDTH = 8,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAMIO_${idx}_IS_ASYNC = 0,   //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] S_AXIS_BRAM_${idx}_IS_INOUT = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_MB_DEPTH = 1,  //depth, number of copies of BRAM args"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_ADDR_WIDTH = 1,"
	} else {
	    puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_ADDR_WIDTH = 1"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input in_bram_allow_in,"
    puts $fp "    input in_bram_allow_out,"
    puts $fp "    input acc_start,"
    puts $fp "    input acc_done,"
    puts $fp "    output \[C_NUM_INPUT_BRAMs-1:0\] in_bram_ready,"
    puts $fp "    output \[C_NUM_INPUT_BRAMs-1:0\] inout_bram_ready,"
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_bram_${idx}_aclk,"
	puts $fp "    input s_axis_bram_${idx}_aresetn,"
	puts $fp "    input s_axis_bram_${idx}_tlast,"
	puts $fp "    input s_axis_bram_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH-1:0\] s_axis_bram_${idx}_tdata,"
	puts $fp "    output s_axis_bram_${idx}_tready,"
	for {set port 0} {$port < $num_ports} {incr port} {
	    puts $fp "    input \[S_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr${port},"
	    puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din${port},"
	    puts $fp "    output \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout${port},"
	    puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_${idx}_we${port},"
	    puts $fp "    input ap_bram_${idx}_en${port},"
	}
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //in-out AXI-Stream output interface ${idx}"
	puts $fp "    input m_axis_bramio_${idx}_aclk,"
	puts $fp "    input m_axis_bramio_${idx}_aresetn,"
	puts $fp "    output m_axis_bramio_${idx}_tlast,"
	puts $fp "    output m_axis_bramio_${idx}_tvalid,  "
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH-1:0\] m_axis_bramio_${idx}_tdata,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input m_axis_bramio_${idx}_tready,"
	} else {
	    puts $fp "    input m_axis_bramio_${idx}_tready"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX_INPUT_BRAMs = ${num};"
    puts $fp "    localparam C_MAX_BRAM_PORTs = ${num_ports};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_INBRAM_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_WIDTH,"
    }
    puts $fp "S_AXIS_BRAM_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_DEPTH,"
    }
    puts $fp "S_AXIS_BRAM_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_DMWIDTH,"
    }
    puts $fp "S_AXIS_BRAM_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_IN_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_IS_ASYNC,"
    }
    puts $fp "S_AXIS_BRAM_0_IS_ASYNC\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_OUT_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAMIO_${val}_IS_ASYNC,"
    }
    puts $fp "M_AXIS_BRAMIO_0_IS_ASYNC\};"
    puts -nonewline $fp "    localparam \[C_MAX_INPUT_BRAMs-1:0\] C_INOUT_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_IS_INOUT,"
    }
    puts $fp "S_AXIS_BRAM_0_IS_INOUT\};"
    puts -nonewline $fp "    localparam \[C_MAX_INPUT_BRAMs*32-1:0\] C_ADDR_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_ADDR_WIDTH,"
    }
    puts $fp "S_AXIS_BRAM_0_ADDR_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_MB_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_MB_DEPTH,"
    }
    puts $fp "S_AXIS_BRAM_0_MB_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_PORTS_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "S_AXIS_BRAM_${val}_PORTS,"
    }
    puts $fp "S_AXIS_BRAM_0_PORTS\};"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] in_clk;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] in_rst;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_clk;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_rst;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv0_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv1_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tkeep \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tstrb \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf0_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf1_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] out_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] bram_addr \[C_NUM_INPUT_BRAMs-1:0\]\[C_MAX_BRAM_PORTs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] bram_din \[C_NUM_INPUT_BRAMs-1:0\]\[C_MAX_BRAM_PORTs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] bram_dout \[C_NUM_INPUT_BRAMs-1:0\]\[C_MAX_BRAM_PORTs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] bram_we \[C_NUM_INPUT_BRAMs-1:0\]\[C_MAX_BRAM_PORTs-1:0\];"
    puts $fp "    wire bram_en \[C_NUM_INPUT_BRAMs-1:0\]\[C_MAX_BRAM_PORTs-1:0\];"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INPUT_BRAMs > ${idx}) begin"
	puts $fp "            assign in_clk\[${idx}\] = s_axis_bram_${idx}_aclk;"
	puts $fp "            assign in_rst\[${idx}\] = s_axis_bram_${idx}_aresetn;"
	puts $fp "            assign tlast\[${idx}\] = s_axis_bram_${idx}_tlast;"
	puts $fp "            assign tvalid\[${idx}\] = s_axis_bram_${idx}_tvalid;"
	puts $fp "            assign tkeep\[${idx}\]\[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] = s_axis_bram_${idx}_tkeep;"
	puts $fp "            assign tstrb\[${idx}\]\[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] = s_axis_bram_${idx}_tstrb;"
	puts $fp "            assign tdata\[${idx}\]\[S_AXIS_BRAM_${idx}_DMWIDTH-1:0\] = s_axis_bram_${idx}_tdata;"
	puts $fp "            assign s_axis_bram_${idx}_tready = tready\[${idx}\];"
	puts $fp "            "
	for {set port 0} {$port < $num_ports} {incr port} {
	    puts $fp "            assign bram_addr\[${idx}\]\[$port\]\[S_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr${port};"
	    puts $fp "            assign bram_din\[${idx}\]\[$port\]\[S_AXIS_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din${port};"
	    puts $fp "            assign ap_bram_${idx}_dout${port} = bram_dout\[${idx}\]\[$port\]\[S_AXIS_BRAM_${idx}_WIDTH-1:0\];"
	    puts $fp "            assign bram_we\[${idx}\]\[$port\]\[S_AXIS_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we${port};"
	    puts $fp "            assign bram_en\[${idx}\]\[$port\] = ap_bram_${idx}_en${port};"
	}
	puts $fp "            "
	puts $fp "            assign out_clk\[${idx}\] = m_axis_bramio_${idx}_aclk;"
	puts $fp "            assign out_rst\[${idx}\] = m_axis_bramio_${idx}_aresetn;"
	puts $fp "            assign dwconv1_tready\[${idx}\] = m_axis_bramio_${idx}_tready;"
	puts $fp "            assign m_axis_bramio_${idx}_tlast = dwconv1_tlast\[${idx}\];"
	puts $fp "            assign m_axis_bramio_${idx}_tvalid = dwconv1_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_bramio_${idx}_tkeep = dwconv1_tkeep\[${idx}\]\[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bramio_${idx}_tstrb = dwconv1_tstrb\[${idx}\]\[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bramio_${idx}_tdata = dwconv1_tdata\[${idx}\]\[M_AXIS_BRAMIO_${idx}_DMWIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_INPUT_BRAMs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_0i ("
    puts $fp "                    .aclk(in_clk\[idx\]),"
    puts $fp "                    .aresetn(in_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv0_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv0_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(dwconv0_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "                "
    puts $fp "                if( C_INOUT_BIT_ARRAY\[idx\] ) begin"
    puts $fp "                    axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                        .C_S_AXIS_TDATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                        .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                        .C_AXIS_TID_WIDTH(1),"
    puts $fp "                        .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                        .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                        .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                        .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                    ) data_width_conv_1i ("
    puts $fp "                        .aclk(out_clk\[idx\]),"
    puts $fp "                        .aresetn(out_rst\[idx\]),"
    puts $fp "                        .aclken(1'b1),"
    puts $fp "                        .s_axis_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                        .s_axis_tready(buf1_tready\[idx\]),"
    puts $fp "                        .s_axis_tdata(buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .s_axis_tstrb({C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                        .s_axis_tkeep({C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                        .s_axis_tlast(buf1_tlast\[idx\]),"
    puts $fp "                        .m_axis_tvalid(dwconv1_tvalid\[idx\]),"
    puts $fp "                        .m_axis_tready(dwconv1_tready\[idx\]),"
    puts $fp "                        .m_axis_tdata(dwconv1_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .m_axis_tstrb(dwconv1_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                        .m_axis_tkeep(dwconv1_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                        .m_axis_tlast(dwconv1_tlast\[idx\])"
    puts $fp "                    );"
    puts $fp "                end"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv0_tlast\[idx\] = tlast\[idx\];"
    puts $fp "                assign dwconv0_tvalid\[idx\] = tvalid\[idx\];"
    puts $fp "                assign tready\[idx\] = dwconv0_tready\[idx\];   //output"
    puts $fp "                assign dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp ""
    puts $fp "                assign dwconv1_tlast\[idx\] = buf1_tlast\[idx\];"
    puts $fp "                assign dwconv1_tvalid\[idx\] = buf1_tvalid\[idx\];"
    puts $fp "                assign buf1_tready\[idx\] = dwconv1_tready\[idx\];   //input"
    puts $fp "                assign dwconv1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv1_tkeep\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign dwconv1_tstrb\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if( C_IN_ASYNC_BIT_ARRAY\[idx\] == 0 ) begin"
    puts $fp "                //use fifo"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(16),"
    puts $fp "                    .C_IS_ASYNC(C_IN_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo0_i ("
    puts $fp "                    .aresetn(in_rst\[idx\]),"
    puts $fp "                    .inclk(in_clk\[idx\]), "
    puts $fp "                    .in_tdata(dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(dwconv0_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(dwconv0_tvalid\[idx\]),"
    puts $fp "                    .in_tready(dwconv0_tready\[idx\]),"
    puts $fp "                    .outclk(acc_clk), "
    puts $fp "                    .out_tdata(buf0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf0_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf0_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf0_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if not, wire the input signals straight through"
    puts $fp "                assign buf0_tlast\[idx\] = dwconv0_tlast\[idx\];"
    puts $fp "                assign buf0_tvalid\[idx\] = dwconv0_tvalid\[idx\];"
    puts $fp "                assign dwconv0_tready\[idx\] = buf0_tready\[idx\];   //output"
    puts $fp "                assign buf0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            if( C_INOUT_BIT_ARRAY\[idx\] ) begin"
    puts $fp "                if( C_OUT_ASYNC_BIT_ARRAY\[idx\] == 0 ) begin"
    puts $fp "                    axis_fifo #("
    puts $fp "                        .C_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                        .C_DATA_DEPTH(16),"
    puts $fp "                        .C_IS_ASYNC(C_OUT_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                    ) axis_fifo1_i ("
    puts $fp "                        .aresetn(acc_aresetn),"
    puts $fp "                        .inclk(acc_clk),"
    puts $fp "                        .in_tdata(out_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .in_tlast(out_tlast\[idx\]),  "
    puts $fp "                        .in_tvalid(out_tvalid\[idx\]),"
    puts $fp "                        .in_tready(out_tready\[idx\]),"
    puts $fp "                        .outclk(out_clk\[idx\]), "
    puts $fp "                        .out_tdata(buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .out_tready(buf1_tready\[idx\]),"
    puts $fp "                        .out_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                        .out_tlast(buf1_tlast\[idx\])"
    puts $fp "                    );"
    puts $fp "                end"
    puts $fp "                else begin"
    puts $fp "                    //if not, wire the input signals straight through"
    puts $fp "                    assign buf1_tlast\[idx\] = out_tlast\[idx\];"
    puts $fp "                    assign buf1_tvalid\[idx\] = out_tvalid\[idx\];"
    puts $fp "                    assign out_tready\[idx\] = buf1_tready\[idx\];   //output"
    puts $fp "                    assign buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = out_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                end"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            axis2bram #( "
    puts $fp "                .C_S_AXIS_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_M_AXIS_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_IS_INOUT(C_INOUT_BIT_ARRAY\[idx:idx\]),"
    puts $fp "                .C_MB_DEPTH(C_MB_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_ADDR_WIDTH(C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_NUM_PORTS(C_PORTS_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis2bram_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ACC_START(acc_start),"
    puts $fp "                .CTRL_ACC_DONE(acc_done),"
    puts $fp "                .CTRL_INREADY(in_bram_ready\[idx\]),"
    puts $fp "                .CTRL_OUTREADY(inout_bram_ready\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .S_AXIS_TLAST(buf0_tlast\[idx\]),"
    puts $fp "                .S_AXIS_TVALID(buf0_tvalid\[idx\]),"
    puts $fp "                .S_AXIS_TDATA(buf0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .S_AXIS_TREADY(buf0_tready\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .M_AXIS_TLAST(out_tlast\[idx\]),"
    puts $fp "                .M_AXIS_TVALID(out_tvalid\[idx\]),"
    puts $fp "                .M_AXIS_TDATA(out_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .M_AXIS_TREADY(out_tready\[idx\]),"
    puts $fp "                //ACC BRAM IF-0"
    puts $fp "                .bram0_addr(bram_addr\[idx\]\[0\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_din(bram_din\[idx\]\[0\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_dout(bram_dout\[idx\]\[0\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_we(bram_we\[idx\]\[0\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram0_en(bram_en\[idx\]\[0\]),"
    puts $fp "                //ACC BRAM IF-1"
    puts $fp "                .bram1_addr(bram_addr\[idx\]\[1\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_din(bram_din\[idx\]\[1\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_dout(bram_dout\[idx\]\[1\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_we(bram_we\[idx\]\[1\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram1_en(bram_en\[idx\]\[1\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_outbram {num num_ports} {
    if {[file exists "hdl/out_bram_args.v"]} {
	file delete -force "hdl/out_bram_args.v"
    }
    set fp [open "hdl/out_bram_args.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module out_bram_args #("
    puts $fp "    parameter C_QUEUE_DEPTH = 16,"
    puts $fp "    parameter C_NUM_OUTPUT_BRAMs = 0, "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter M_AXIS_BRAM_${idx}_PORTS = 1,            //number of bram ports (dual-ported, partitioned)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_WIDTH = 8,     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_DEPTH = 2,      //depth of FIFO in adapter for input bram interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_IS_ASYNC = 0,   //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_MB_DEPTH = 1, //depth of BRAM in adapter for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_ADDR_WIDTH = 1,"
	} else {
	    puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_ADDR_WIDTH = 1"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //control interface"
    puts $fp "    input dm_clk,"
    puts $fp "    input dm_aresetn,"
    puts $fp "    input outbram_allow,"
    puts $fp "    input acc_start,"
    puts $fp "    input acc_done,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ready,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_canstart,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write,"
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //out AXI-Stream output interface ${idx}"
	puts $fp "    input m_axis_bram_${idx}_aclk,"
	puts $fp "    input m_axis_bram_${idx}_aresetn,"
	puts $fp "    output m_axis_bram_${idx}_tlast,"
	puts $fp "    output m_axis_bram_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bram_${idx}_tdata,"
	puts $fp "    input m_axis_bram_${idx}_tready,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din0,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\]ap_bram_${idx}_we0,"
	puts $fp "    input ap_bram_${idx}_en0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr1,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din1,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout1,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\]ap_bram_${idx}_we1,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_bram_${idx}_en1,"
	} else {
	    puts $fp "    input ap_bram_${idx}_en1"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp ""
    puts $fp "    localparam C_MAX_OUTPUT_BRAMs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_PORT_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_PORTS,"
    }
    puts $fp "M_AXIS_BRAM_0_PORTS\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_OUTBRAM_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_WIDTH,"
    }
    puts $fp "M_AXIS_BRAM_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_DEPTH,"
    }
    puts $fp "M_AXIS_BRAM_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_DMWIDTH,"
    }
    puts $fp "M_AXIS_BRAM_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_IS_ASYNC_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_IS_ASYNC,"
    }
    puts $fp "M_AXIS_BRAM_0_IS_ASYNC\};"
    puts -nonewline $fp "    localparam \[C_MAX_OUTPUT_BRAMs*32-1:0\] C_ADDR_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_ADDR_WIDTH,"
    }
    puts $fp "M_AXIS_BRAM_0_ADDR_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_OUTPUT_BRAMs*32-1:0\] C_MB_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIS_BRAM_${val}_MB_DEPTH,"
    }
    puts $fp "M_AXIS_BRAM_0_MB_DEPTH\};"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] axis_clk;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] axis_rst;"
    puts $fp "    "
    puts $fp "    wire \[31:0\] fifo_depth \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] fifo_depth_empty;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] fifo_depth_read;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv1_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tkeep \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tstrb \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf1_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] out_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] en0;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] en1;"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTPUT_BRAMs > ${idx}) begin"
	puts $fp "            assign addr0\[${idx}\]\[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr0;"
	puts $fp "            assign din0\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din0;"
	puts $fp "            assign ap_bram_${idx}_dout0 = dout0\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we0\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we0;"
	puts $fp "            assign en0\[${idx}\] = ap_bram_${idx}_en0;"
	puts $fp "            assign addr1\[${idx}\]\[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr1;"
	puts $fp "            assign din1\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din1;"
	puts $fp "            assign ap_bram_${idx}_dout1 = dout1\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we1\[${idx}\]\[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we1;"
	puts $fp "            assign en1\[${idx}\] = ap_bram_${idx}_en1;"
	puts $fp "            "
	puts $fp "            assign axis_clk\[${idx}\] = m_axis_bram_${idx}_aclk;"
	puts $fp "            assign axis_rst\[${idx}\] = m_axis_bram_${idx}_aresetn;"
	puts $fp "            assign dwconv1_tready\[${idx}\] = m_axis_bram_${idx}_tready;"
	puts $fp "            assign m_axis_bram_${idx}_tlast = dwconv1_tlast\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tvalid = dwconv1_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tkeep = dwconv1_tkeep\[${idx}\]\[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tstrb = dwconv1_tstrb\[${idx}\]\[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tdata = dwconv1_tdata\[${idx}\]\[M_AXIS_BRAM_${idx}_DMWIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the bram2axis modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_OUTPUT_BRAMs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_1i ("
    puts $fp "                    .aclk(axis_clk\[idx\]),"
    puts $fp "                    .aresetn(axis_rst\[idx\]),"
    puts $fp "                    .aclken(1'b1),"
    puts $fp "                    .s_axis_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(buf1_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb({C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                    .s_axis_tkeep({C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                    .s_axis_tlast(buf1_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv1_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv1_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv1_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(dwconv1_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(dwconv1_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(dwconv1_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv1_tlast\[idx\] = buf1_tlast\[idx\];"
    puts $fp "                assign dwconv1_tvalid\[idx\] = buf1_tvalid\[idx\];"
    puts $fp "                assign buf1_tready\[idx\] = dwconv1_tready\[idx\];   //input"
    puts $fp "                assign dwconv1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv1_tkeep\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign dwconv1_tstrb\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "            end"
    puts $fp "                        "
    puts $fp "            if(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\] == 0) begin"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(16),"
    puts $fp "                    .C_IS_ASYNC(C_IS_ASYNC_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "                ) axis_fifo1_i ("
    puts $fp "                    .aresetn(acc_aresetn),"
    puts $fp "                    .inclk(acc_clk),"
    puts $fp "                    .in_tdata(out_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(out_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(out_tvalid\[idx\]),"
    puts $fp "                    .in_tready(out_tready\[idx\]),"
    puts $fp "                    .outclk(axis_clk\[idx\]), "
    puts $fp "                    .out_tdata(buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf1_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf1_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign buf1_tlast\[idx\] = out_tlast\[idx\];"
    puts $fp "                assign buf1_tvalid\[idx\] = out_tvalid\[idx\];"
    puts $fp "                assign out_tready\[idx\] = buf1_tready\[idx\];   //input"
    puts $fp "                assign buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = out_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            fifo #( "
    puts $fp "                .WIDTH(32),"
    puts $fp "                .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "            ) depth_queue_i ("
    puts $fp "                .wr_clk(dm_clk),"
    puts $fp "                .din(outbram_depth\[(idx+1)*32-1:idx*32\]),"
    puts $fp "                .write(outbram_depth_write\[idx\]),"
    puts $fp "                .full(),"
    puts $fp "                .dout(fifo_depth\[idx\]),"
    puts $fp "                .read(fifo_depth_read\[idx\]),"
    puts $fp "                .empty(fifo_depth_empty\[idx\]),"
    puts $fp "                .rd_clk(acc_clk), "
    puts $fp "                .rst(0) "     
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            localparam NUM_BYTES = C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8; "
    puts $fp "            wire \[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] bram_data_depth_m1; "
    puts $fp "            assign bram_data_depth_m1 = fifo_depth\[idx\] - NUM_BYTES; "
    puts $fp "            "    
    puts $fp "            bram2axis #( "
    puts $fp "                .C_AXIS_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_ADDR_WIDTH(C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_MB_DEPTH(C_MB_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_NUM_PORTS(C_PORT_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) bram2axis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_aresetn),"
    puts $fp "                .CTRL_ACC_START(acc_start),"
    puts $fp "                .CTRL_ACC_DONE(acc_done),"
    puts $fp "                .CTRL_READY(outbram_ready\[idx\]),"
    puts $fp "                .CTRL_CANSTART(outbram_canstart\[idx\]),"
    puts $fp "                .DATA_DEPTH_M1(bram_data_depth_m1),"
    puts $fp "                .DATA_DEPTH_READ(fifo_depth_read\[idx\]),"
    puts $fp "                .DATA_DEPTH_EMPTY(fifo_depth_empty\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .AXIS_TLAST(out_tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(out_tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(out_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(out_tready\[idx\]),"
    puts $fp "                //ACC BRAM IF-0"
    puts $fp "                .bram0_addr(addr0\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_din(din0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_dout(dout0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_we(we0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram0_en(en0\[idx\]),"
    puts $fp "                //ACC BRAM IF-1"
    puts $fp "                .bram1_addr(addr1\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_din(din1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_dout(dout1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_we(we1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram1_en(en1\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_aximm {num} {
    if {[file exists "hdl/aximm_args.v"]} {
	file delete -force "hdl/aximm_args.v"
    }
    set fp [open "hdl/aximm_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module aximm_args #("
    puts $fp "    parameter C_NUM_AXIMMs = 0,"
    puts $fp "    parameter M_AXIMM_ADDR_WIDTH = 32,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter M_AXIMM_${idx}_DATA_WIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_ARUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_AWUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_BUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_RUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_ARID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_AWID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_BID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_RID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WID_WIDTH = 0,"
	} else {
	    puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WID_WIDTH = 0"
	}
    }
    puts $fp " ) ("
    puts $fp "    input acc_clk,"
    puts $fp "    input dm_clk,"
    puts $fp "    //control interface"
    puts $fp "    input aresetn,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //AXI-MM pass-through interface ${idx}"
#	puts $fp "    input wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\]                      AP_AXIMM_${idx}_AWID,"
	puts $fp "    input wire \[M_AXIMM_ADDR_WIDTH-1:0\]   AP_AXIMM_${idx}_AWADDR,"
	puts $fp "    input wire \[7:0\]                      AP_AXIMM_${idx}_AWLEN,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_AWSIZE,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_AWBURST,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_AWLOCK,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWCACHE,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_AWPROT,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWREGION,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWQOS,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_AWUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_AWVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_AWREADY,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\]                      AP_AXIMM_${idx}_WID,"
	puts $fp "    input wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   AP_AXIMM_${idx}_WDATA,"
	puts $fp "    input wire \[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\] AP_AXIMM_${idx}_WSTRB,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_WLAST,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_WUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_WVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_WREADY,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\]                      AP_AXIMM_${idx}_BID,"
	puts $fp "    output  wire \[1:0\]                      AP_AXIMM_${idx}_BRESP,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_BUSER,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_BVALID,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_BREADY,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\]                      AP_AXIMM_${idx}_ARID,"
	puts $fp "    input wire \[M_AXIMM_ADDR_WIDTH-1:0\]   AP_AXIMM_${idx}_ARADDR,"
	puts $fp "    input wire \[7:0\]                      AP_AXIMM_${idx}_ARLEN,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_ARSIZE,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_ARBURST,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_ARLOCK,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARCACHE,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_ARPROT,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARREGION,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARQOS,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_ARUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_ARVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_ARREADY,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\]                      AP_AXIMM_${idx}_RID,"
	puts $fp "    output  wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   AP_AXIMM_${idx}_RDATA,"
	puts $fp "    output  wire \[1:0\]                      AP_AXIMM_${idx}_RRESP,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_RLAST,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_RUSER,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_RVALID,"
	puts $fp "    input  wire                            AP_AXIMM_${idx}_RREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\]                      M_AXIMM_${idx}_AWID,"
	puts $fp "    output wire \[M_AXIMM_ADDR_WIDTH-1:0\]   M_AXIMM_${idx}_AWADDR,"
	puts $fp "    output wire \[7:0\]                      M_AXIMM_${idx}_AWLEN,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_AWSIZE,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_AWBURST,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_AWLOCK,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWCACHE,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_AWPROT,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWREGION,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWQOS,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_AWUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_AWVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_AWREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\]                      M_AXIMM_${idx}_WID,"
	puts $fp "    output wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   M_AXIMM_${idx}_WDATA,"
	puts $fp "    output wire \[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\] M_AXIMM_${idx}_WSTRB,"
	puts $fp "    output wire                            M_AXIMM_${idx}_WLAST,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_WUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_WVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_WREADY,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\]                      M_AXIMM_${idx}_BID,"
	puts $fp "    input  wire \[1:0\]                      M_AXIMM_${idx}_BRESP,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_BUSER,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_BVALID,"
	puts $fp "    output wire                            M_AXIMM_${idx}_BREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\]                      M_AXIMM_${idx}_ARID,"
	puts $fp "    output wire \[M_AXIMM_ADDR_WIDTH-1:0\]   M_AXIMM_${idx}_ARADDR,"
	puts $fp "    output wire \[7:0\]                      M_AXIMM_${idx}_ARLEN,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_ARSIZE,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_ARBURST,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_ARLOCK,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARCACHE,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_ARPROT,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARREGION,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARQOS,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_ARUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_ARVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_ARREADY,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\]                      M_AXIMM_${idx}_RID,"
	puts $fp "    input  wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   M_AXIMM_${idx}_RDATA,"
	puts $fp "    input  wire \[1:0\]                      M_AXIMM_${idx}_RRESP,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_RLAST,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_RUSER,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_RVALID,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    output wire                            M_AXIMM_${idx}_RREADY,"
	} else {
	    puts $fp "    output wire                            M_AXIMM_${idx}_RREADY"
	}
    }
    puts $fp "    );"
    puts $fp ""
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts $fp "    localparam C_MAX_AXIMMs = ${num};"
    puts -nonewline $fp "    localparam \[(C_MAX_AXIMMs*32)-1:0\] M_AXIMM_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_DATA_WIDTH,"
    }
    puts $fp "M_AXIMM_0_DATA_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_ARUSER_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_ARUSER_WIDTH,"
    }
    puts $fp "M_AXIMM_0_ARUSER_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_AWUSER_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_AWUSER_WIDTH,"
    }
    puts $fp "M_AXIMM_0_AWUSER_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_BUSER_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_BUSER_WIDTH,"
    }
    puts $fp "M_AXIMM_0_BUSER_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_RUSER_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_RUSER_WIDTH,"
    }
    puts $fp "M_AXIMM_0_RUSER_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_WUSER_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_WUSER_WIDTH,"
    }
    puts $fp "M_AXIMM_0_WUSER_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_ARID_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_ARID_WIDTH,"
    }
    puts $fp "M_AXIMM_0_ARID_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_AWID_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_AWID_WIDTH,"
    }
    puts $fp "M_AXIMM_0_AWID_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_BID_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_BID_WIDTH,"
    }
    puts $fp "M_AXIMM_0_BID_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_RID_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_RID_WIDTH,"
    }
    puts $fp "M_AXIMM_0_RID_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_AXIMMs-1:0\] M_AXIMM_WID_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "M_AXIMM_${val}_WID_WIDTH,"
    }
    puts $fp "M_AXIMM_0_WID_WIDTH\};"
    puts $fp "    "
#    puts $fp "    wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\] ap_AWID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[M_AXIMM_ADDR_WIDTH-1:0\]   ap_AWADDR \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[7:0\] ap_AWLEN \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] ap_AWSIZE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_AWBURST \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_AWLOCK \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_AWCACHE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] ap_AWPROT \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_AWREGION \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_AWQOS \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\] ap_AWUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_AWVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_AWREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\] ap_WID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   ap_WDATA \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] ap_WSTRB \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_WLAST \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\] ap_WUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_WVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_WREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\] ap_BID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_BRESP \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\] ap_BUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_BVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_BREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\] ap_ARID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[M_AXIMM_ADDR_WIDTH-1:0\]   ap_ARADDR \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[7:0\] ap_ARLEN \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] ap_ARSIZE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_ARBURST \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_ARLOCK \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_ARCACHE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] ap_ARPROT \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_ARREGION \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] ap_ARQOS \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\] ap_ARUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_ARVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_ARREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\] ap_RID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   ap_RDATA \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] ap_RRESP \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_RLAST \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\] ap_RUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_RVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       ap_RREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\] dm_AWID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[M_AXIMM_ADDR_WIDTH-1:0\]   dm_AWADDR \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[7:0\] dm_AWLEN \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] dm_AWSIZE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_AWBURST \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_AWLOCK \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_AWCACHE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] dm_AWPROT \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_AWREGION \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_AWQOS \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\] dm_AWUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_AWVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_AWREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\] dm_WID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   dm_WDATA \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dm_WSTRB \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_WLAST \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\] dm_WUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_WVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_WREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\] dm_BID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_BRESP \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\] dm_BUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_BVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_BREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\] dm_ARID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[M_AXIMM_ADDR_WIDTH-1:0\]   dm_ARADDR \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[7:0\] dm_ARLEN \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] dm_ARSIZE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_ARBURST \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_ARLOCK \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_ARCACHE \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[2:0\] dm_ARPROT \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_ARREGION \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[3:0\] dm_ARQOS \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\] dm_ARUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_ARVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_ARREADY \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\] dm_RID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   dm_RDATA \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire \[1:0\] dm_RRESP \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_RLAST \[C_NUM_AXIMMs-1:0\];"
#    puts $fp "    wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\] dm_RUSER \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_RVALID \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    wire       dm_RREADY \[C_NUM_AXIMMs-1:0\];"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_AXIMMs > ${idx}) begin"
#	puts $fp "            assign ap_AWID\[${idx}\] = AP_AXIMM_${idx}_AWID;"
	puts $fp "            assign ap_AWADDR\[${idx}\]\[M_AXIMM_ADDR_WIDTH-1:0\] = AP_AXIMM_${idx}_AWADDR;"
	puts $fp "            assign ap_AWLEN\[${idx}\] = AP_AXIMM_${idx}_AWLEN;"
	puts $fp "            assign ap_AWSIZE\[${idx}\] = AP_AXIMM_${idx}_AWSIZE;"
	puts $fp "            assign ap_AWBURST\[${idx}\] = AP_AXIMM_${idx}_AWBURST;"
	puts $fp "            assign ap_AWLOCK\[${idx}\] = AP_AXIMM_${idx}_AWLOCK;"
	puts $fp "            assign ap_AWCACHE\[${idx}\] = AP_AXIMM_${idx}_AWCACHE;"
	puts $fp "            assign ap_AWPROT\[${idx}\] = AP_AXIMM_${idx}_AWPROT;"
	puts $fp "            assign ap_AWREGION\[${idx}\] = AP_AXIMM_${idx}_AWREGION;"
	puts $fp "            assign ap_AWQOS\[${idx}\] = AP_AXIMM_${idx}_AWQOS;"
#	puts $fp "            assign ap_AWUSER\[${idx}\] = AP_AXIMM_${idx}_AWUSER;"
	puts $fp "            assign ap_AWVALID\[${idx}\] = AP_AXIMM_${idx}_AWVALID;"
	puts $fp "            assign AP_AXIMM_${idx}_AWREADY = ap_AWREADY\[${idx}\];"
#	puts $fp "            assign ap_WID\[${idx}\] = AP_AXIMM_${idx}_WID;"
	puts $fp "            assign ap_WDATA\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH-1:0\] = AP_AXIMM_${idx}_WDATA;"
	puts $fp "            assign ap_WSTRB\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\] = AP_AXIMM_${idx}_WSTRB;"
	puts $fp "            assign ap_WLAST\[${idx}\] = AP_AXIMM_${idx}_WLAST;"
#	puts $fp "            assign ap_WUSER\[${idx}\] = AP_AXIMM_${idx}_WUSER;"
	puts $fp "            assign ap_WVALID\[${idx}\] = AP_AXIMM_${idx}_WVALID;"
	puts $fp "            assign AP_AXIMM_${idx}_WREADY = ap_WREADY\[${idx}\];"
#	puts $fp "            assign AP_AXIMM_${idx}_BID = ap_BID\[${idx}\];"
	puts $fp "            assign AP_AXIMM_${idx}_BRESP = ap_BRESP\[${idx}\];"
#	puts $fp "            assign AP_AXIMM_${idx}_BUSER = ap_BUSER\[${idx}\];"
	puts $fp "            assign AP_AXIMM_${idx}_BVALID = ap_BVALID\[${idx}\];"
	puts $fp "            assign ap_BREADY\[${idx}\] = AP_AXIMM_${idx}_BREADY;"
#	puts $fp "            assign ap_ARID\[${idx}\] = AP_AXIMM_${idx}_ARID;"
	puts $fp "            assign ap_ARADDR\[${idx}\]\[M_AXIMM_ADDR_WIDTH-1:0\] = AP_AXIMM_${idx}_ARADDR;"
	puts $fp "            assign ap_ARLEN\[${idx}\] = AP_AXIMM_${idx}_ARLEN;"
	puts $fp "            assign ap_ARSIZE\[${idx}\] = AP_AXIMM_${idx}_ARSIZE;"
	puts $fp "            assign ap_ARBURST\[${idx}\] = AP_AXIMM_${idx}_ARBURST;"
	puts $fp "            assign ap_ARLOCK\[${idx}\] = AP_AXIMM_${idx}_ARLOCK;"
	puts $fp "            assign ap_ARCACHE\[${idx}\] = AP_AXIMM_${idx}_ARCACHE;"
	puts $fp "            assign ap_ARPROT\[${idx}\] = AP_AXIMM_${idx}_ARPROT;"
	puts $fp "            assign ap_ARREGION\[${idx}\] = AP_AXIMM_${idx}_ARREGION;"
	puts $fp "            assign ap_ARQOS\[${idx}\] = AP_AXIMM_${idx}_ARQOS;"
#	puts $fp "            assign ap_ARUSER\[${idx}\] = AP_AXIMM_${idx}_ARUSER;"
	puts $fp "            assign ap_ARVALID\[${idx}\] = AP_AXIMM_${idx}_ARVALID;"
	puts $fp "            assign AP_AXIMM_${idx}_ARREADY = ap_ARREADY\[${idx}\];"
#	puts $fp "            assign AP_AXIMM_${idx}_RID = ap_RID\[${idx}\];"
	puts $fp "            assign AP_AXIMM_${idx}_RDATA = ap_RDATA\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH-1:0\];"
	puts $fp "            assign AP_AXIMM_${idx}_RRESP = ap_RRESP\[${idx}\];"
	puts $fp "            assign AP_AXIMM_${idx}_RLAST = ap_RLAST\[${idx}\];"
#	puts $fp "            assign AP_AXIMM_${idx}_RUSER = ap_RUSER\[${idx}\];"
	puts $fp "            assign AP_AXIMM_${idx}_RVALID = ap_RVALID\[${idx}\];"
	puts $fp "            assign ap_RREADY\[${idx}\] = AP_AXIMM_${idx}_RREADY;"
#	puts $fp "            assign M_AXIMM_${idx}_AWID = dm_AWID\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWADDR = dm_AWADDR\[${idx}\]\[M_AXIMM_ADDR_WIDTH-1:0\];"
	puts $fp "            assign M_AXIMM_${idx}_AWLEN = dm_AWLEN\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWSIZE = dm_AWSIZE\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWBURST = dm_AWBURST\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWLOCK = dm_AWLOCK\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWCACHE = dm_AWCACHE\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWPROT = dm_AWPROT\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWREGION = dm_AWREGION\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWQOS = dm_AWQOS\[${idx}\];"
#	puts $fp "            assign M_AXIMM_${idx}_AWUSER = dm_AWUSER\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_AWVALID = dm_AWVALID\[${idx}\];"
	puts $fp "            assign dm_AWREADY\[${idx}\] = M_AXIMM_${idx}_AWREADY;"
#	puts $fp "            assign M_AXIMM_${idx}_WID = dm_WID\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_WDATA = dm_WDATA\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH-1:0\];"
	puts $fp "            assign M_AXIMM_${idx}_WSTRB = dm_WSTRB\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\];"
	puts $fp "            assign M_AXIMM_${idx}_WLAST = dm_WLAST\[${idx}\];"
#	puts $fp "            assign M_AXIMM_${idx}_WUSER = dm_WUSER\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_WVALID = dm_WVALID\[${idx}\];"
	puts $fp "            assign dm_WREADY\[${idx}\] = M_AXIMM_${idx}_WREADY;"
#	puts $fp "            assign dm_BID\[${idx}\] = M_AXIMM_${idx}_BID;"
	puts $fp "            assign dm_BRESP\[${idx}\] = M_AXIMM_${idx}_BRESP;"
#	puts $fp "            assign dm_BUSER\[${idx}\] = M_AXIMM_${idx}_BUSER;"
	puts $fp "            assign dm_BVALID\[${idx}\] = M_AXIMM_${idx}_BVALID;"
	puts $fp "            assign M_AXIMM_${idx}_BREADY = dm_BREADY\[${idx}\];"
#	puts $fp "            assign M_AXIMM_${idx}_ARID = dm_ARID\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARADDR = dm_ARADDR\[${idx}\]\[M_AXIMM_ADDR_WIDTH-1:0\];"
	puts $fp "            assign M_AXIMM_${idx}_ARLEN = dm_ARLEN\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARSIZE = dm_ARSIZE\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARBURST = dm_ARBURST\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARLOCK = dm_ARLOCK\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARCACHE = dm_ARCACHE\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARPROT = dm_ARPROT\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARREGION = dm_ARREGION\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARQOS = dm_ARQOS\[${idx}\];"
#	puts $fp "            assign M_AXIMM_${idx}_ARUSER = dm_ARUSER\[${idx}\];"
	puts $fp "            assign M_AXIMM_${idx}_ARVALID = dm_ARVALID\[${idx}\];"
	puts $fp "            assign dm_ARREADY\[${idx}\] = M_AXIMM_${idx}_ARREADY;"
#	puts $fp "            assign dm_RID\[${idx}\] = M_AXIMM_${idx}_RID;"
	puts $fp "            assign dm_RDATA\[${idx}\]\[M_AXIMM_${idx}_DATA_WIDTH-1:0\] = M_AXIMM_${idx}_RDATA;"
	puts $fp "            assign dm_RRESP\[${idx}\] = M_AXIMM_${idx}_RRESP;"
	puts $fp "            assign dm_RLAST\[${idx}\] = M_AXIMM_${idx}_RLAST;"
#	puts $fp "            assign dm_RUSER\[${idx}\] = M_AXIMM_${idx}_RUSER;"
	puts $fp "            assign dm_RVALID\[${idx}\] = M_AXIMM_${idx}_RVALID;"
	puts $fp "            assign M_AXIMM_${idx}_RREADY = dm_RREADY\[${idx}\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate    "
    puts $fp "    "
    puts $fp "    //wire up"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_AXIMMs; idx=idx+1) begin: AXIMM_GEN"
    puts $fp "            //just wire signals straight through"
#    puts $fp "            assign dm_AWID\[idx\] = ap_AWID\[idx\];"
    puts $fp "            assign dm_AWADDR\[idx\]\[M_AXIMM_ADDR_WIDTH-1:0\] = ap_AWADDR\[idx\]\[M_AXIMM_ADDR_WIDTH-1:0\];"
    puts $fp "            assign dm_AWLEN\[idx\] = ap_AWLEN\[idx\];"
    puts $fp "            assign dm_AWSIZE\[idx\] = ap_AWSIZE\[idx\];"
    puts $fp "            assign dm_AWBURST\[idx\] = ap_AWBURST\[idx\];"
    puts $fp "            assign dm_AWLOCK\[idx\] = ap_AWLOCK\[idx\];"
    puts $fp "            assign dm_AWCACHE\[idx\] = ap_AWCACHE\[idx\];"
    puts $fp "            assign dm_AWPROT\[idx\] = ap_AWPROT\[idx\];"
    puts $fp "            assign dm_AWREGION\[idx\] = ap_AWREGION\[idx\];"
    puts $fp "            assign dm_AWQOS\[idx\] = ap_AWQOS\[idx\];"
#    puts $fp "            assign dm_AWUSER\[idx\] = ap_AWUSER\[idx\];"
    puts $fp "            assign dm_AWVALID\[idx\] = ap_AWVALID\[idx\];"
    puts $fp "            assign ap_AWREADY\[idx\] = dm_AWREADY\[idx\];"
#    puts $fp "            assign dm_WID\[idx\] = ap_WID\[idx\];"
    puts $fp "            assign dm_WDATA\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = ap_WDATA\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            assign dm_WSTRB\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = ap_WSTRB\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "            assign dm_WLAST\[idx\] = ap_WLAST\[idx\];"
#    puts $fp "            assign dm_WUSER\[idx\] = ap_WUSER\[idx\];"
    puts $fp "            assign dm_WVALID\[idx\] = ap_WVALID\[idx\];"
    puts $fp "            assign ap_WREADY\[idx\] = dm_WREADY\[idx\];"
#    puts $fp "            assign ap_BID\[idx\] = dm_BID\[idx\];"
    puts $fp "            assign ap_BRESP\[idx\] = dm_BRESP\[idx\];"
#    puts $fp "            assign ap_BUSER\[idx\] = dm_BUSER\[idx\];"
    puts $fp "            assign ap_BVALID\[idx\] = dm_BVALID\[idx\];"
    puts $fp "            assign dm_BREADY\[idx\] = ap_BREADY\[idx\];"
#    puts $fp "            assign dm_ARID\[idx\] = ap_ARID\[idx\];"
    puts $fp "            assign dm_ARADDR\[idx\]\[M_AXIMM_ADDR_WIDTH-1:0\] = ap_ARADDR\[idx\]\[M_AXIMM_ADDR_WIDTH-1:0\];"
    puts $fp "            assign dm_ARLEN\[idx\] = ap_ARLEN\[idx\];"
    puts $fp "            assign dm_ARSIZE\[idx\] = ap_ARSIZE\[idx\];"
    puts $fp "            assign dm_ARBURST\[idx\] = ap_ARBURST\[idx\];"
    puts $fp "            assign dm_ARLOCK\[idx\] = ap_ARLOCK\[idx\];"
    puts $fp "            assign dm_ARCACHE\[idx\] = ap_ARCACHE\[idx\];"
    puts $fp "            assign dm_ARPROT\[idx\] = ap_ARPROT\[idx\];"
    puts $fp "            assign dm_ARREGION\[idx\] = ap_ARREGION\[idx\];"
    puts $fp "            assign dm_ARQOS\[idx\] = ap_ARQOS\[idx\];"
#    puts $fp "            assign dm_ARUSER\[idx\] = ap_ARUSER\[idx\];"
    puts $fp "            assign dm_ARVALID\[idx\] = ap_ARVALID\[idx\];"
    puts $fp "            assign ap_ARREADY\[idx\] = dm_ARREADY\[idx\];"
#    puts $fp "            assign ap_RID\[idx\] = dm_RID\[idx\];"
    puts $fp "            assign ap_RDATA\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = dm_RDATA\[idx\]\[M_AXIMM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            assign ap_RRESP\[idx\] = dm_RRESP\[idx\];"
    puts $fp "            assign ap_RLAST\[idx\] = dm_RLAST\[idx\];"
#    puts $fp "            assign ap_RUSER\[idx\] = dm_RUSER\[idx\];"
    puts $fp "            assign ap_RVALID\[idx\] = dm_RVALID\[idx\];"
    puts $fp "            assign dm_RREADY\[idx\] = ap_RREADY\[idx\];"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"

    close $fp
}

proc gen_top {num} {
    if {[file exists "hdl/top.v"]} {
	file delete -force "hdl/top.v"
    }
    set fp [open "hdl/top.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module top #("
    puts $fp "    //adapter parameters"
    puts $fp "    parameter C_HAS_CTRL = 1,"
    puts $fp "    parameter C_ACC_RESET_POLARITY = 0,"
    puts $fp "    parameter C_QUEUE_DEPTH = 16,"
    puts $fp "    "
    puts $fp "    //scalar parameters"
    puts $fp "    parameter C_N_INPUT_SCALARS = 0,"
    puts $fp "    parameter C_N_OUTPUT_SCALARS = 0,"
    puts $fp "    parameter C_FIFO_DEPTH = 16,"
    puts $fp "    parameter C_HAS_RETURN = 0,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] C_INPUT_SCALAR_${idx}_WIDTH = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_IS_DIRECT = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_SCALAR_${idx}_DIRECT_DEPTH = 16,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\]  C_OUTPUT_SCALAR_${idx}_WIDTH = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\]  M_AXIS_SCALAR_${idx}_IS_DIRECT = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_SCALAR_${idx}_DIRECT_DEPTH = 16,"
    }
    puts $fp "    "
    puts $fp "    //fifo arg parameters"
    puts $fp "    parameter C_NUM_INPUT_FIFOs = 0,                //number of input fifo interfaces on the accelerator"
    puts $fp "    parameter C_NUM_OUTPUT_FIFOs = 0,               //number of output fifo interfaces on the accelerator"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_WIDTH = 8,     //width of input fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_DEPTH = 16,      //depth of FIFO in adapter for input fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input fifo interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_FIFO_${idx}_BYTE_WIDTH = 8,     //width of input fifo interface on the accelerator, padded"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_WIDTH = 8,    //width of output fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_DEPTH = 16,     //depth of FIFO in adapter for output fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_DMWIDTH = 8,  //width of AXIS interface from DM to adapter for output fifo interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_FIFO_${idx}_BYTE_WIDTH = 8,     //width of input fifo interface on the accelerator, padded"
    }
    puts $fp "    "
    puts $fp "    //bram arg parameters"
    puts $fp "    parameter C_NUM_INPUT_BRAMs = 0, "
    puts $fp "    parameter C_NUM_OUTPUT_BRAMs = 0, "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter S_AXIS_BRAM_${idx}_PORTS = 1,            //number of bram ports (dual-ported, partitioned)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_WIDTH = 8,     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_DEPTH = 2,     //depth of BRAM in adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAMIO_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for inout (output) bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAMIO_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] S_AXIS_BRAM_${idx}_IS_INOUT = 0,         //enables the input bram also for output"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_BRAM_${idx}_MB_DEPTH = 1,  //depth, number of copies of BRAM args"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter M_AXIS_BRAM_${idx}_PORTS = 1,           //number of bram ports (dual-ported, partitioned)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_WIDTH = 8,    //width of output bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_DEPTH = 2,    //depth of BRAM in adapter for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_DMWIDTH = 8,  //width of AXIS interface from adapter to DM for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_BRAM_${idx}_MB_DEPTH = 1, //depth of BRAM in adapter for output bram interface"
    }
    puts $fp "    "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter S_AXIS_BRAM_${idx}_ADDR_WIDTH = 1,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter M_AXIS_BRAM_${idx}_ADDR_WIDTH = 1,"
    }
    puts $fp "    //axis arg parameters"
    puts $fp "    parameter C_NUM_INPUT_AXISs = 0,                //number of input fifo interfaces on the accelerator"
    puts $fp "    parameter C_NUM_OUTPUT_AXISs = 0,               //number of output fifo interfaces on the accelerator"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_WIDTH = 8,     //width of input AXIS interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_DEPTH = 16,      //depth of AXIS in adapter for input AXIS interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_DMWIDTH = 8,   //width of AXIS interface from DM to adapter for input AXIS interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] S_AXIS_IARG_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_WIDTH = 8,    //width of output AXIS interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_DEPTH = 16,     //depth of AXIS in adapter for output AXIS interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_DMWIDTH = 8,  //width of AXIS interface from DM to adapter for output AXIS interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_IS_ASYNC = 0,  //should fifo buffer be asynchronous (0) or synchronours (1)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[31:0\] M_AXIS_OARG_${idx}_GEN_TLAST = 0,  //generate TLAST signal for output AXIS interface"
    }
    puts $fp "    //aximm arg parameters"
    puts $fp "    parameter C_NUM_AXIMMs = 0,                //number of aximm interfaces on the accelerator"
    puts $fp "    parameter M_AXIMM_ADDR_WIDTH = 32,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter M_AXIMM_${idx}_DATA_WIDTH = 32,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_ARUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_AWUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_BUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_RUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WUSER_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_ARID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_AWID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_BID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_RID_WIDTH = 0,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WID_WIDTH = 0,"
	} else {
	    puts $fp "    parameter \[0:0\] M_AXIMM_${idx}_WID_WIDTH = 0"
	}
    }
    puts $fp " ) ("
    puts $fp "    //axi lite interface"
    puts $fp "    input s_axi_aclk,"
    puts $fp "    input s_axi_aresetn,"
    puts $fp "    input \[31 : 0\] S_AXI_AWADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_AWPROT,"
    puts $fp "    input S_AXI_AWVALID,"
    puts $fp "    output S_AXI_AWREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_WDATA,"
    puts $fp "    input \[3 : 0\] S_AXI_WSTRB,"
    puts $fp "    input S_AXI_WVALID,"
    puts $fp "    output S_AXI_WREADY,"
    puts $fp "    output \[1 : 0\] S_AXI_BRESP,"
    puts $fp "    output S_AXI_BVALID,"
    puts $fp "    input S_AXI_BREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_ARADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_ARPROT,"
    puts $fp "    input S_AXI_ARVALID,"
    puts $fp "    output S_AXI_ARREADY,"
    puts $fp "    output \[31 : 0\] S_AXI_RDATA,"
    puts $fp "    output \[1 : 0\] S_AXI_RRESP,"
    puts $fp "    output S_AXI_RVALID,"
    puts $fp "    input S_AXI_RREADY,"
    puts $fp "    //acc clock"
    puts $fp "    input acc_aclk,"
    puts $fp "    input acc_aresetn,"
    puts $fp "    //acc interface"
    puts $fp "    output ap_resetn,"
    puts $fp "    output ap_clk,"
    puts $fp "    output ap_start,"
    puts $fp "    input ap_idle,"
    puts $fp "    input ap_done,"
    puts $fp "    input ap_ready,"
    puts $fp "    output ap_continue,"
    puts $fp "    //-----------------------------------------------------"
    puts $fp "    //input scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    output \[C_INPUT_SCALAR_${idx}_WIDTH-1:0\] ap_iscalar_${idx}_dout,"
    }
    puts $fp "    //input scalar direct AXIS interfaces"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to Scalar interface ${idx}"
	puts $fp "    input s_axis_scalar_${idx}_aclk,"
	puts $fp "    input s_axis_scalar_${idx}_aresetn,"
	puts $fp "    input s_axis_scalar_${idx}_tlast,"
	puts $fp "    input s_axis_scalar_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] s_axis_scalar_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] s_axis_scalar_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\] s_axis_scalar_${idx}_tdata,"
	puts $fp "    output s_axis_scalar_${idx}_tready,"
    }
    puts $fp "    //output scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input \[C_OUTPUT_SCALAR_${idx}_WIDTH-1:0\] ap_oscalar_${idx}_din,"
    }
    puts $fp "    //output scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input ap_oscalar_${idx}_vld,"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output Scalar to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_scalar_${idx}_aclk,"
	puts $fp "    input m_axis_scalar_${idx}_aresetn,"
	puts $fp "    output m_axis_scalar_${idx}_tlast,"
	puts $fp "    output m_axis_scalar_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] m_axis_scalar_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH/8-1:0\] m_axis_scalar_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH-1:0\] m_axis_scalar_${idx}_tdata,"
	puts $fp "    input m_axis_scalar_${idx}_tready,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_fifo_${idx}_aclk,"
	puts $fp "    input s_axis_fifo_${idx}_aresetn,"
	puts $fp "    input s_axis_fifo_${idx}_tlast,"
	puts $fp "    input s_axis_fifo_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_FIFO_${idx}_DMWIDTH-1:0\] s_axis_fifo_${idx}_tdata,"
	puts $fp "    output s_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_iarg_${idx}_empty_n,"
	puts $fp "    output \[S_AXIS_FIFO_${idx}_WIDTH-1:0\] ap_fifo_iarg_${idx}_dout,"
	puts $fp "    input ap_fifo_iarg_${idx}_read,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output FIFO to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_fifo_${idx}_aclk,"
	puts $fp "    input m_axis_fifo_${idx}_aresetn,"
	puts $fp "    output m_axis_fifo_${idx}_tlast,"
	puts $fp "    output m_axis_fifo_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_FIFO_${idx}_DMWIDTH-1:0\] m_axis_fifo_${idx}_tdata,"
	puts $fp "    input m_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_oarg_${idx}_full_n,"
	puts $fp "    input \[M_AXIS_FIFO_${idx}_WIDTH-1:0\] ap_fifo_oarg_${idx}_din,"
	puts $fp "    input ap_fifo_oarg_${idx}_write,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to BRAM interface ${idx}"
	puts $fp "    input s_axis_bram_${idx}_aclk,"
	puts $fp "    input s_axis_bram_${idx}_aresetn,"
	puts $fp "    input s_axis_bram_${idx}_tlast,"
	puts $fp "    input s_axis_bram_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_DMWIDTH-1:0\] s_axis_bram_${idx}_tdata,"
	puts $fp "    output s_axis_bram_${idx}_tready,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_iarg_${idx}_addr0,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_din0,"
	puts $fp "    output \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_dout0,"
	puts $fp "    input ap_bram_iarg_${idx}_clk0,"
	puts $fp "    input ap_bram_iarg_${idx}_rst0,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_iarg_${idx}_we0,"
	puts $fp "    input ap_bram_iarg_${idx}_en0,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_iarg_${idx}_addr1,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_din1,"
	puts $fp "    output \[S_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_dout1,"
	puts $fp "    input ap_bram_iarg_${idx}_clk1,"
	puts $fp "    input ap_bram_iarg_${idx}_rst1,"
	puts $fp "    input \[S_AXIS_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_iarg_${idx}_we1,"
	puts $fp "    input ap_bram_iarg_${idx}_en1,"
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //in-out BRAM AXI-Stream output interface ${idx}"
	puts $fp "    input m_axis_bramio_${idx}_aclk,"
	puts $fp "    input m_axis_bramio_${idx}_aresetn,"
	puts $fp "    output m_axis_bramio_${idx}_tlast,"
	puts $fp "    output m_axis_bramio_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_BRAMIO_${idx}_DMWIDTH-1:0\] m_axis_bramio_${idx}_tdata,"
	puts $fp "    input m_axis_bramio_${idx}_tready,"
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //out BRAM to AXI-Stream interface ${idx}"
	puts $fp "    input m_axis_bram_${idx}_aclk,"
	puts $fp "    input m_axis_bram_${idx}_aresetn,"
	puts $fp "    output m_axis_bram_${idx}_tlast,"
	puts $fp "    output m_axis_bram_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bram_${idx}_tdata,"
	puts $fp "    input m_axis_bram_${idx}_tready,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_oarg_${idx}_addr0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_din0,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_dout0,"
	puts $fp "    input ap_bram_oarg_${idx}_clk0,"
	puts $fp "    input ap_bram_oarg_${idx}_rst0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_oarg_${idx}_we0,"
	puts $fp "    input ap_bram_oarg_${idx}_en0,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_oarg_${idx}_addr1,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_din1,"
	puts $fp "    output \[M_AXIS_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_dout1,"
	puts $fp "    input ap_bram_oarg_${idx}_clk1,"
	puts $fp "    input ap_bram_oarg_${idx}_rst1,"
	puts $fp "    input \[M_AXIS_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_oarg_${idx}_we1,"
	puts $fp "    input ap_bram_oarg_${idx}_en1,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream pass-through interface ${idx}"
	puts $fp "    input s_axis_iarg_${idx}_aclk,"
	puts $fp "    input s_axis_iarg_${idx}_aresetn,"
	puts $fp "    input s_axis_iarg_${idx}_tlast,"
	puts $fp "    input s_axis_iarg_${idx}_tvalid,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] s_axis_iarg_${idx}_tkeep,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH/8-1:0\] s_axis_iarg_${idx}_tstrb,"
	puts $fp "    input \[S_AXIS_IARG_${idx}_DMWIDTH-1:0\] s_axis_iarg_${idx}_tdata,"
	puts $fp "    output s_axis_iarg_${idx}_tready,"
	puts $fp "    input ap_axis_iarg_${idx}_tready,"
	puts $fp "    output ap_axis_iarg_${idx}_tlast,"
	puts $fp "    output ap_axis_iarg_${idx}_tvalid,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH/8-1:0\] ap_axis_iarg_${idx}_tkeep,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH/8-1:0\] ap_axis_iarg_${idx}_tstrb,"
	puts $fp "    output \[S_AXIS_IARG_${idx}_WIDTH-1:0\] ap_axis_iarg_${idx}_tdata,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output AXI-Stream pass-through interface ${idx}"
	puts $fp "    input m_axis_oarg_${idx}_aclk,"
	puts $fp "    input m_axis_oarg_${idx}_aresetn,"
	puts $fp "    output m_axis_oarg_${idx}_tlast,"
	puts $fp "    output m_axis_oarg_${idx}_tvalid,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\] m_axis_oarg_${idx}_tkeep,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH/8-1:0\] m_axis_oarg_${idx}_tstrb,"
	puts $fp "    output \[M_AXIS_OARG_${idx}_DMWIDTH-1:0\] m_axis_oarg_${idx}_tdata,"
	puts $fp "    input m_axis_oarg_${idx}_tready,"
	puts $fp "    input ap_axis_oarg_${idx}_tlast,"
	puts $fp "    input ap_axis_oarg_${idx}_tvalid,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH/8-1:0\] ap_axis_oarg_${idx}_tkeep,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH/8-1:0\] ap_axis_oarg_${idx}_tstrb,"
	puts $fp "    input \[M_AXIS_OARG_${idx}_WIDTH-1:0\] ap_axis_oarg_${idx}_tdata,"
	puts $fp "    output ap_axis_oarg_${idx}_tready,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //AXI-MM pass-through interface ${idx}"
#	puts $fp "    input wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\]                      AP_AXIMM_${idx}_AWID,"
	puts $fp "    input wire \[M_AXIMM_ADDR_WIDTH-1:0\]   AP_AXIMM_${idx}_AWADDR,"
	puts $fp "    input wire \[7:0\]                      AP_AXIMM_${idx}_AWLEN,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_AWSIZE,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_AWBURST,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_AWLOCK,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWCACHE,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_AWPROT,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWREGION,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_AWQOS,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_AWUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_AWVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_AWREADY,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\]                      AP_AXIMM_${idx}_WID,"
	puts $fp "    input wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   AP_AXIMM_${idx}_WDATA,"
	puts $fp "    input wire \[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\] AP_AXIMM_${idx}_WSTRB,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_WLAST,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_WUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_WVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_WREADY,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\]                      AP_AXIMM_${idx}_BID,"
	puts $fp "    output  wire \[1:0\]                      AP_AXIMM_${idx}_BRESP,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_BUSER,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_BVALID,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_BREADY,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\]                      AP_AXIMM_${idx}_ARID,"
	puts $fp "    input wire \[M_AXIMM_ADDR_WIDTH-1:0\]   AP_AXIMM_${idx}_ARADDR,"
	puts $fp "    input wire \[7:0\]                      AP_AXIMM_${idx}_ARLEN,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_ARSIZE,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_ARBURST,"
	puts $fp "    input wire \[1:0\]                      AP_AXIMM_${idx}_ARLOCK,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARCACHE,"
	puts $fp "    input wire \[2:0\]                      AP_AXIMM_${idx}_ARPROT,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARREGION,"
	puts $fp "    input wire \[3:0\]                      AP_AXIMM_${idx}_ARQOS,"
#	puts $fp "    input wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_ARUSER,"
	puts $fp "    input wire                            AP_AXIMM_${idx}_ARVALID,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_ARREADY,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\]                      AP_AXIMM_${idx}_RID,"
	puts $fp "    output  wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   AP_AXIMM_${idx}_RDATA,"
	puts $fp "    output  wire \[1:0\]                      AP_AXIMM_${idx}_RRESP,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_RLAST,"
#	puts $fp "    output  wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\]                      AP_AXIMM_${idx}_RUSER,"
	puts $fp "    output  wire                            AP_AXIMM_${idx}_RVALID,"
	puts $fp "    input  wire                            AP_AXIMM_${idx}_RREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_AWID_WIDTH-1:0\]                      M_AXIMM_${idx}_AWID,"
	puts $fp "    output wire \[M_AXIMM_ADDR_WIDTH-1:0\]   M_AXIMM_${idx}_AWADDR,"
	puts $fp "    output wire \[7:0\]                      M_AXIMM_${idx}_AWLEN,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_AWSIZE,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_AWBURST,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_AWLOCK,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWCACHE,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_AWPROT,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWREGION,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_AWQOS,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_AWUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_AWUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_AWVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_AWREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_WID_WIDTH-1:0\]                      M_AXIMM_${idx}_WID,"
	puts $fp "    output wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   M_AXIMM_${idx}_WDATA,"
	puts $fp "    output wire \[M_AXIMM_${idx}_DATA_WIDTH/8-1:0\] M_AXIMM_${idx}_WSTRB,"
	puts $fp "    output wire                            M_AXIMM_${idx}_WLAST,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_WUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_WUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_WVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_WREADY,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_BID_WIDTH-1:0\]                      M_AXIMM_${idx}_BID,"
	puts $fp "    input  wire \[1:0\]                      M_AXIMM_${idx}_BRESP,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_BUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_BUSER,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_BVALID,"
	puts $fp "    output wire                            M_AXIMM_${idx}_BREADY,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_ARID_WIDTH-1:0\]                      M_AXIMM_${idx}_ARID,"
	puts $fp "    output wire \[M_AXIMM_ADDR_WIDTH-1:0\]   M_AXIMM_${idx}_ARADDR,"
	puts $fp "    output wire \[7:0\]                      M_AXIMM_${idx}_ARLEN,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_ARSIZE,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_ARBURST,"
	puts $fp "    output wire \[1:0\]                      M_AXIMM_${idx}_ARLOCK,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARCACHE,"
	puts $fp "    output wire \[2:0\]                      M_AXIMM_${idx}_ARPROT,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARREGION,"
	puts $fp "    output wire \[3:0\]                      M_AXIMM_${idx}_ARQOS,"
#	puts $fp "    output wire \[M_AXIMM_${idx}_ARUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_ARUSER,"
	puts $fp "    output wire                            M_AXIMM_${idx}_ARVALID,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_ARREADY,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_RID_WIDTH-1:0\]                      M_AXIMM_${idx}_RID,"
	puts $fp "    input  wire \[M_AXIMM_${idx}_DATA_WIDTH-1:0\]   M_AXIMM_${idx}_RDATA,"
	puts $fp "    input  wire \[1:0\]                      M_AXIMM_${idx}_RRESP,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_RLAST,"
#	puts $fp "    input  wire \[M_AXIMM_${idx}_RUSER_WIDTH-1:0\]                      M_AXIMM_${idx}_RUSER,"
	puts $fp "    input  wire                            M_AXIMM_${idx}_RVALID,"
    puts $fp "    output wire                            M_AXIMM_${idx}_RREADY,"
    }
	puts $fp "    output wire                                ap_done_irq"    
    puts $fp ");"
    puts $fp ""
    puts $fp ""
    puts $fp ""
    puts $fp "    //scalar interface "
    puts $fp "    wire \[31:0\] scalar_write_addr;"
    puts $fp "    wire \[31:0\] scalar_read_addr;"
    puts $fp "    wire \[31:0\] scalar_din;"
    puts $fp "    wire scalar_we;"
    puts $fp "    wire scalar_re;"
    puts $fp "    wire \[31:0\] scalar_dout;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_next;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_fifo_empty;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_fifo_full;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_fifo_empty;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_fifo_full;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_empty;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_dout;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_read;"
    puts $fp "    "
    puts $fp "    //wire in bram control interface"
    puts $fp "    wire inbram_ctrl_allow;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] inbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] inoutbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs*32-1:0\] inbram_depth;"
    puts $fp "    "
    puts $fp "    //wire in fifo control interface"
    puts $fp "    wire infifo_ctrl_allow;"
    puts $fp "    "
    puts $fp "    //wire out bram control interface"
    puts $fp "    wire outbram_ctrl_allow;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_canstart;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write;"
    puts $fp "    "
    puts $fp "    //wire out fifo control interface"
    puts $fp "    wire outfifo_ctrl_allow;"
    puts $fp ""
    puts $fp "    //wire in axis control interface"
    puts $fp "    wire inaxis_ctrl_allow;"
    puts $fp "    //wire out axis control interface"
    puts $fp "    wire outaxis_ctrl_allow;"
    puts $fp ""
    puts $fp "    adapter #("
    puts $fp "        .C_ACC_RESET_POLARITY(C_ACC_RESET_POLARITY),"
    puts $fp "        .C_NUM_INPUT_SCALARS(C_N_INPUT_SCALARS),"
    puts $fp "        .C_NUM_OUTPUT_SCALARS(C_N_OUTPUT_SCALARS),"
    puts $fp "        .C_QUEUE_DEPTH(C_QUEUE_DEPTH),"
    puts $fp "        .C_NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    puts $fp "        .C_NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    puts $fp "        .C_NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    puts $fp "        .C_NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs)"
    puts $fp "    ) adapter_i ("
    puts $fp "        .S_AXI_ACLK(s_axi_aclk),"
    puts $fp "        .S_AXI_ARESETN(s_axi_aresetn),"
    puts $fp "        .S_AXI_AWADDR(S_AXI_AWADDR),"
    puts $fp "        .S_AXI_AWPROT(S_AXI_AWPROT),"
    puts $fp "        .S_AXI_AWVALID(S_AXI_AWVALID),"
    puts $fp "        .S_AXI_AWREADY(S_AXI_AWREADY),"
    puts $fp "        .S_AXI_WDATA(S_AXI_WDATA),"
    puts $fp "        .S_AXI_WSTRB(S_AXI_WSTRB),"
    puts $fp "        .S_AXI_WVALID(S_AXI_WVALID),"
    puts $fp "        .S_AXI_WREADY(S_AXI_WREADY),"
    puts $fp "        .S_AXI_BRESP(S_AXI_BRESP),"
    puts $fp "        .S_AXI_BVALID(S_AXI_BVALID),"
    puts $fp "        .S_AXI_BREADY(S_AXI_BREADY),"
    puts $fp "        .S_AXI_ARADDR(S_AXI_ARADDR),"
    puts $fp "        .S_AXI_ARPROT(S_AXI_ARPROT),"
    puts $fp "        .S_AXI_ARVALID(S_AXI_ARVALID),"
    puts $fp "        .S_AXI_ARREADY(S_AXI_ARREADY),"
    puts $fp "        .S_AXI_RDATA(S_AXI_RDATA),"
    puts $fp "        .S_AXI_RRESP(S_AXI_RRESP),"
    puts $fp "        .S_AXI_RVALID(S_AXI_RVALID),"
    puts $fp "        .S_AXI_RREADY(S_AXI_RREADY),"
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_rstn(acc_aresetn),"
    puts $fp "        .ap_rst(ap_resetn),"
    puts $fp "        .ap_start(ap_start),"
    puts $fp "        .ap_start_single(ap_start_single),"
    puts $fp "        .ap_idle(ap_idle),"
    puts $fp "        .ap_done(ap_done),"
    puts $fp "        .ap_ready(ap_ready),"
    puts $fp "        .ap_continue(ap_continue),"
    puts $fp "        .ap_clk(ap_clk),"
    puts $fp "        .scalar_write_addr(scalar_write_addr),"
    puts $fp "        .scalar_read_addr(scalar_read_addr),"
    puts $fp "        .scalar_din(scalar_din),"
    puts $fp "        .scalar_we(scalar_we),"
    puts $fp "        .scalar_re(scalar_re),"
    puts $fp "        .scalar_dout(scalar_dout),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_fifo_full(inscalar_fifo_full),"
    puts $fp "        .outscalar_fifo_empty(outscalar_fifo_empty),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .outscalar_null_empty(outscalar_null_empty),"
    puts $fp "        .outscalar_null_dout(outscalar_null_dout),"
    puts $fp "        .outscalar_null_read(outscalar_null_read),"
    puts $fp "        .inbram_ctrl_allow(inbram_ctrl_allow),"
    puts $fp "        .inbram_ctrl_ready(inbram_ctrl_ready),"
    puts $fp "        .inoutbram_ctrl_ready(inoutbram_ctrl_ready),"
    puts $fp "        .infifo_ctrl_allow(infifo_ctrl_allow),"
    puts $fp "        .outbram_ctrl_allow(outbram_ctrl_allow),"
    puts $fp "        .outbram_ctrl_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_canstart(outbram_ctrl_canstart),"
    puts $fp "        .outbram_depth(outbram_depth),"
    puts $fp "        .outbram_depth_write(outbram_depth_write),"
    puts $fp "        .outfifo_ctrl_allow(outfifo_ctrl_allow),"
    puts $fp "        .inaxis_ctrl_allow(inaxis_ctrl_allow),"
    puts $fp "        .outaxis_ctrl_allow(outaxis_ctrl_allow),"
    puts $fp "        .ap_done_irq(ap_done_irq)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    scalar #("
    puts $fp "        .C_NUM_INSCALARS(C_N_INPUT_SCALARS),"
    puts $fp "        .C_NUM_OUTSCALARS(C_N_OUTPUT_SCALARS),"
    puts $fp "        .C_FIFO_DEPTH(C_FIFO_DEPTH),"
    puts $fp "        .C_HAS_RETURN(C_HAS_RETURN),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INSCALAR_${idx}_BITS(C_INPUT_SCALAR_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_SCALAR_${idx}_IS_DIRECT(S_AXIS_SCALAR_${idx}_IS_DIRECT),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH(S_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC(S_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_SCALAR_${idx}_DIRECT_DEPTH(S_AXIS_SCALAR_${idx}_DIRECT_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTSCALAR_${idx}_BITS(C_OUTPUT_SCALAR_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_SCALAR_${idx}_IS_DIRECT(M_AXIS_SCALAR_${idx}_IS_DIRECT),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH(M_AXIS_SCALAR_${idx}_DIRECT_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC(M_AXIS_SCALAR_${idx}_DIRECT_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIS_SCALAR_${idx}_DIRECT_DEPTH(M_AXIS_SCALAR_${idx}_DIRECT_DEPTH),"
	} else {
	    puts $fp "        .M_AXIS_SCALAR_${idx}_DIRECT_DEPTH(M_AXIS_SCALAR_${idx}_DIRECT_DEPTH)"
	}
    }
    puts $fp "    ) scalar_i ("
    puts $fp "        .clk(s_axi_aclk),"
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        //control interface"
    puts $fp "        .scalar_read_addr(scalar_read_addr),"
    puts $fp "        .scalar_re(scalar_re),"
    puts $fp "        .scalar_dout(scalar_dout),"
    puts $fp "        .scalar_we(scalar_we),"
    puts $fp "        .scalar_write_addr(scalar_write_addr),"
    puts $fp "        .scalar_din(scalar_din),"
    puts $fp "        .outscalar_capture(ap_done),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_fifo_full(inscalar_fifo_full),"
    puts $fp "        .outscalar_fifo_empty(outscalar_fifo_empty),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .outscalar_null_empty(outscalar_null_empty),"
    puts $fp "        .outscalar_null_dout(outscalar_null_dout),"
    puts $fp "        .outscalar_null_read(outscalar_null_read),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .inscalar${idx}(ap_iscalar_${idx}_dout),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_scalar_${idx}_aclk(s_axis_scalar_${idx}_aclk),"
	puts $fp "        .s_axis_scalar_${idx}_aresetn(s_axis_scalar_${idx}_aresetn),"
	puts $fp "        .s_axis_scalar_${idx}_tlast(s_axis_scalar_${idx}_tlast),"
	puts $fp "        .s_axis_scalar_${idx}_tvalid(s_axis_scalar_${idx}_tvalid),"
	puts $fp "        .s_axis_scalar_${idx}_tkeep(s_axis_scalar_${idx}_tkeep),"
	puts $fp "        .s_axis_scalar_${idx}_tstrb(s_axis_scalar_${idx}_tstrb),"
	puts $fp "        .s_axis_scalar_${idx}_tdata(s_axis_scalar_${idx}_tdata),"
	puts $fp "        .s_axis_scalar_${idx}_tready(s_axis_scalar_${idx}_tready),"
    }
    puts $fp "        //.scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .outscalar${idx}(ap_oscalar_${idx}_din),"
    }
    puts $fp "        //.scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .outscalar${idx}_vld(ap_oscalar_${idx}_vld),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_scalar_${idx}_aclk(m_axis_scalar_${idx}_aclk),"
	puts $fp "        .m_axis_scalar_${idx}_aresetn(m_axis_scalar_${idx}_aresetn),"
	puts $fp "        .m_axis_scalar_${idx}_tlast(m_axis_scalar_${idx}_tlast),"
	puts $fp "        .m_axis_scalar_${idx}_tvalid(m_axis_scalar_${idx}_tvalid),"
	puts $fp "        .m_axis_scalar_${idx}_tkeep(m_axis_scalar_${idx}_tkeep),"
	puts $fp "        .m_axis_scalar_${idx}_tstrb(m_axis_scalar_${idx}_tstrb),"
	puts $fp "        .m_axis_scalar_${idx}_tdata(m_axis_scalar_${idx}_tdata),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .m_axis_scalar_${idx}_tready(m_axis_scalar_${idx}_tready),"
	} else {
	    puts $fp "        .m_axis_scalar_${idx}_tready(m_axis_scalar_${idx}_tready)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    in_fifo_args #("
    puts $fp "        .C_NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_FIFO_${idx}_WIDTH(S_AXIS_FIFO_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_FIFO_${idx}_DEPTH(S_AXIS_FIFO_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_FIFO_${idx}_IS_ASYNC(S_AXIS_FIFO_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_FIFO_${idx}_BYTE_WIDTH(S_AXIS_FIFO_${idx}_BYTE_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .S_AXIS_FIFO_${idx}_DMWIDTH(S_AXIS_FIFO_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .S_AXIS_FIFO_${idx}_DMWIDTH(S_AXIS_FIFO_${idx}_DMWIDTH)"
	}
    }
    puts $fp "    ) in_fifo_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .in_fifo_allow(infifo_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_fifo_${idx}_aclk(s_axis_fifo_${idx}_aclk),"
	puts $fp "        .s_axis_fifo_${idx}_aresetn(s_axis_fifo_${idx}_aresetn),"
	puts $fp "        .s_axis_fifo_${idx}_tlast(s_axis_fifo_${idx}_tlast),"
	puts $fp "        .s_axis_fifo_${idx}_tvalid(s_axis_fifo_${idx}_tvalid),"
	puts $fp "        .s_axis_fifo_${idx}_tkeep(s_axis_fifo_${idx}_tkeep),"
	puts $fp "        .s_axis_fifo_${idx}_tstrb(s_axis_fifo_${idx}_tstrb),"
	puts $fp "        .s_axis_fifo_${idx}_tdata(s_axis_fifo_${idx}_tdata),"
	puts $fp "        .s_axis_fifo_${idx}_tready(s_axis_fifo_${idx}_tready),"
	puts $fp "        .ap_fifo_iarg_${idx}_empty_n(ap_fifo_iarg_${idx}_empty_n),"
	puts $fp "        .ap_fifo_iarg_${idx}_dout(ap_fifo_iarg_${idx}_dout),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_fifo_iarg_${idx}_read(ap_fifo_iarg_${idx}_read),"
	} else {
	    puts $fp "        .ap_fifo_iarg_${idx}_read(ap_fifo_iarg_${idx}_read)"
	}
    }
    puts $fp "    );"
    puts $fp "        "
    puts $fp "    out_fifo_args #("
    puts $fp "        .C_NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_FIFO_${idx}_WIDTH(M_AXIS_FIFO_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_FIFO_${idx}_DEPTH(M_AXIS_FIFO_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_FIFO_${idx}_IS_ASYNC(M_AXIS_FIFO_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_FIFO_${idx}_BYTE_WIDTH(M_AXIS_FIFO_${idx}_BYTE_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIS_FIFO_${idx}_DMWIDTH(M_AXIS_FIFO_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .M_AXIS_FIFO_${idx}_DMWIDTH(M_AXIS_FIFO_${idx}_DMWIDTH)"
	}
    } 
    puts $fp "    ) out_fifo_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .out_fifo_allow(outfifo_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_fifo_${idx}_aclk(m_axis_fifo_${idx}_aclk),"
	puts $fp "        .m_axis_fifo_${idx}_aresetn(m_axis_fifo_${idx}_aresetn),"
	puts $fp "        .m_axis_fifo_${idx}_tlast(m_axis_fifo_${idx}_tlast),"
	puts $fp "        .m_axis_fifo_${idx}_tvalid(m_axis_fifo_${idx}_tvalid),"
	puts $fp "        .m_axis_fifo_${idx}_tkeep(m_axis_fifo_${idx}_tkeep),"
	puts $fp "        .m_axis_fifo_${idx}_tstrb(m_axis_fifo_${idx}_tstrb),"
	puts $fp "        .m_axis_fifo_${idx}_tdata(m_axis_fifo_${idx}_tdata),"
	puts $fp "        .m_axis_fifo_${idx}_tready(m_axis_fifo_${idx}_tready),"
	puts $fp "        .ap_fifo_oarg_${idx}_full_n(ap_fifo_oarg_${idx}_full_n),"
	puts $fp "        .ap_fifo_oarg_${idx}_din(ap_fifo_oarg_${idx}_din),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_fifo_oarg_${idx}_write(ap_fifo_oarg_${idx}_write),"
	} else {
	    puts $fp "        .ap_fifo_oarg_${idx}_write(ap_fifo_oarg_${idx}_write)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    "
    puts $fp "    in_axis_args #("
    puts $fp "        .C_NUM_INPUT_AXISs(C_NUM_INPUT_AXISs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_IARG_${idx}_WIDTH(S_AXIS_IARG_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_IARG_${idx}_DEPTH(S_AXIS_IARG_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_IARG_${idx}_IS_ASYNC(S_AXIS_IARG_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .S_AXIS_IARG_${idx}_DMWIDTH(S_AXIS_IARG_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .S_AXIS_IARG_${idx}_DMWIDTH(S_AXIS_IARG_${idx}_DMWIDTH)"
	}
    }
    puts $fp "    ) in_axis_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .in_axis_allow(inaxis_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_iarg_${idx}_aclk(s_axis_iarg_${idx}_aclk),"
	puts $fp "        .s_axis_iarg_${idx}_aresetn(s_axis_iarg_${idx}_aresetn),"
	puts $fp "        .s_axis_iarg_${idx}_tlast(s_axis_iarg_${idx}_tlast),"
	puts $fp "        .s_axis_iarg_${idx}_tvalid(s_axis_iarg_${idx}_tvalid),"
	puts $fp "        .s_axis_iarg_${idx}_tkeep(s_axis_iarg_${idx}_tkeep),"
	puts $fp "        .s_axis_iarg_${idx}_tstrb(s_axis_iarg_${idx}_tstrb),"
	puts $fp "        .s_axis_iarg_${idx}_tdata(s_axis_iarg_${idx}_tdata),"
	puts $fp "        .s_axis_iarg_${idx}_tready(s_axis_iarg_${idx}_tready),"
	puts $fp "        .ap_axis_iarg_${idx}_tlast(ap_axis_iarg_${idx}_tlast),"
	puts $fp "        .ap_axis_iarg_${idx}_tvalid(ap_axis_iarg_${idx}_tvalid),"
	puts $fp "        .ap_axis_iarg_${idx}_tkeep(ap_axis_iarg_${idx}_tkeep),"
	puts $fp "        .ap_axis_iarg_${idx}_tstrb(ap_axis_iarg_${idx}_tstrb),"
	puts $fp "        .ap_axis_iarg_${idx}_tdata(ap_axis_iarg_${idx}_tdata),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_axis_iarg_${idx}_tready(ap_axis_iarg_${idx}_tready),"
	} else {
	    puts $fp "        .ap_axis_iarg_${idx}_tready(ap_axis_iarg_${idx}_tready)"
	}
    }
    puts $fp "    );"
    puts $fp "        "
    puts $fp "    out_axis_args #("
    puts $fp "        .C_NUM_OUTPUT_AXISs(C_NUM_OUTPUT_AXISs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_OARG_${idx}_WIDTH(M_AXIS_OARG_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_OARG_${idx}_DEPTH(M_AXIS_OARG_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_OARG_${idx}_IS_ASYNC(M_AXIS_OARG_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_OARG_${idx}_GEN_TLAST(M_AXIS_OARG_${idx}_GEN_TLAST),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIS_OARG_${idx}_DMWIDTH(M_AXIS_OARG_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .M_AXIS_OARG_${idx}_DMWIDTH(M_AXIS_OARG_${idx}_DMWIDTH)"
	}
    } 
    puts $fp "    ) out_axis_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .out_axis_allow(outaxis_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_oarg_${idx}_aclk(m_axis_oarg_${idx}_aclk),"
	puts $fp "        .m_axis_oarg_${idx}_aresetn(m_axis_oarg_${idx}_aresetn),"
	puts $fp "        .m_axis_oarg_${idx}_tlast(m_axis_oarg_${idx}_tlast),"
	puts $fp "        .m_axis_oarg_${idx}_tvalid(m_axis_oarg_${idx}_tvalid),"
	puts $fp "        .m_axis_oarg_${idx}_tkeep(m_axis_oarg_${idx}_tkeep),"
	puts $fp "        .m_axis_oarg_${idx}_tstrb(m_axis_oarg_${idx}_tstrb),"
	puts $fp "        .m_axis_oarg_${idx}_tdata(m_axis_oarg_${idx}_tdata),"
	puts $fp "        .m_axis_oarg_${idx}_tready(m_axis_oarg_${idx}_tready),"
	puts $fp "        .ap_axis_oarg_${idx}_tlast(ap_axis_oarg_${idx}_tlast),"
	puts $fp "        .ap_axis_oarg_${idx}_tvalid(ap_axis_oarg_${idx}_tvalid),"
	puts $fp "        .ap_axis_oarg_${idx}_tkeep(ap_axis_oarg_${idx}_tkeep),"
	puts $fp "        .ap_axis_oarg_${idx}_tstrb(ap_axis_oarg_${idx}_tstrb),"
	puts $fp "        .ap_axis_oarg_${idx}_tdata(ap_axis_oarg_${idx}_tdata),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_axis_oarg_${idx}_tready(ap_axis_oarg_${idx}_tready),"
	} else {
	    puts $fp "        .ap_axis_oarg_${idx}_tready(ap_axis_oarg_${idx}_tready)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    aximm_args #("
    puts $fp "        .C_NUM_AXIMMs(C_NUM_AXIMMs),"
    puts $fp "        .M_AXIMM_ADDR_WIDTH(M_AXIMM_ADDR_WIDTH),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_ARUSER_WIDTH(M_AXIMM_${idx}_ARUSER_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_AWUSER_WIDTH(M_AXIMM_${idx}_AWUSER_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_WUSER_WIDTH(M_AXIMM_${idx}_WUSER_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_BUSER_WIDTH(M_AXIMM_${idx}_BUSER_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_RUSER_WIDTH(M_AXIMM_${idx}_RUSER_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_ARID_WIDTH(M_AXIMM_${idx}_ARID_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_AWID_WIDTH(M_AXIMM_${idx}_AWID_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_WID_WIDTH(M_AXIMM_${idx}_WID_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_BID_WIDTH(M_AXIMM_${idx}_BID_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIMM_${idx}_RID_WIDTH(M_AXIMM_${idx}_RID_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIMM_${idx}_DATA_WIDTH(M_AXIMM_${idx}_DATA_WIDTH),"
	} else {
	    puts $fp "        .M_AXIMM_${idx}_DATA_WIDTH(M_AXIMM_${idx}_DATA_WIDTH)"
	}
    }
    puts $fp "    ) aximm_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .aresetn(s_axi_aresetn),"
    for {set idx 0} {$idx < $num} {incr idx} {
#	puts $fp "        .AP_AXIMM_${idx}_AWID(AP_AXIMM_${idx}_AWID),"
	puts $fp "        .AP_AXIMM_${idx}_AWADDR(AP_AXIMM_${idx}_AWADDR),"
	puts $fp "        .AP_AXIMM_${idx}_AWLEN(AP_AXIMM_${idx}_AWLEN),"
	puts $fp "        .AP_AXIMM_${idx}_AWSIZE(AP_AXIMM_${idx}_AWSIZE),"
	puts $fp "        .AP_AXIMM_${idx}_AWBURST(AP_AXIMM_${idx}_AWBURST),"
	puts $fp "        .AP_AXIMM_${idx}_AWLOCK(AP_AXIMM_${idx}_AWLOCK),"
	puts $fp "        .AP_AXIMM_${idx}_AWCACHE(AP_AXIMM_${idx}_AWCACHE),"
	puts $fp "        .AP_AXIMM_${idx}_AWPROT(AP_AXIMM_${idx}_AWPROT),"
	puts $fp "        .AP_AXIMM_${idx}_AWREGION(AP_AXIMM_${idx}_AWREGION),"
	puts $fp "        .AP_AXIMM_${idx}_AWQOS(AP_AXIMM_${idx}_AWQOS),"
#	puts $fp "        .AP_AXIMM_${idx}_AWUSER(AP_AXIMM_${idx}_AWUSER),"
	puts $fp "        .AP_AXIMM_${idx}_AWVALID(AP_AXIMM_${idx}_AWVALID),"
	puts $fp "        .AP_AXIMM_${idx}_AWREADY(AP_AXIMM_${idx}_AWREADY),"
#	puts $fp "        .AP_AXIMM_${idx}_WID(AP_AXIMM_${idx}_WID),"
	puts $fp "        .AP_AXIMM_${idx}_WDATA(AP_AXIMM_${idx}_WDATA),"
	puts $fp "        .AP_AXIMM_${idx}_WSTRB(AP_AXIMM_${idx}_WSTRB),"
	puts $fp "        .AP_AXIMM_${idx}_WLAST(AP_AXIMM_${idx}_WLAST),"
#	puts $fp "        .AP_AXIMM_${idx}_WUSER(AP_AXIMM_${idx}_WUSER),"
	puts $fp "        .AP_AXIMM_${idx}_WVALID(AP_AXIMM_${idx}_WVALID),"
	puts $fp "        .AP_AXIMM_${idx}_WREADY(AP_AXIMM_${idx}_WREADY),"
#	puts $fp "        .AP_AXIMM_${idx}_BID(AP_AXIMM_${idx}_BID),"
	puts $fp "        .AP_AXIMM_${idx}_BRESP(AP_AXIMM_${idx}_BRESP),"
#	puts $fp "        .AP_AXIMM_${idx}_BUSER(AP_AXIMM_${idx}_BUSER),"
	puts $fp "        .AP_AXIMM_${idx}_BVALID(AP_AXIMM_${idx}_BVALID),"
	puts $fp "        .AP_AXIMM_${idx}_BREADY(AP_AXIMM_${idx}_BREADY),"
#	puts $fp "        .AP_AXIMM_${idx}_ARID(AP_AXIMM_${idx}_ARID),"
	puts $fp "        .AP_AXIMM_${idx}_ARADDR(AP_AXIMM_${idx}_ARADDR),"
	puts $fp "        .AP_AXIMM_${idx}_ARLEN(AP_AXIMM_${idx}_ARLEN),"
	puts $fp "        .AP_AXIMM_${idx}_ARSIZE(AP_AXIMM_${idx}_ARSIZE),"
	puts $fp "        .AP_AXIMM_${idx}_ARBURST(AP_AXIMM_${idx}_ARBURST),"
	puts $fp "        .AP_AXIMM_${idx}_ARLOCK(AP_AXIMM_${idx}_ARLOCK),"
	puts $fp "        .AP_AXIMM_${idx}_ARCACHE(AP_AXIMM_${idx}_ARCACHE),"
	puts $fp "        .AP_AXIMM_${idx}_ARPROT(AP_AXIMM_${idx}_ARPROT),"
	puts $fp "        .AP_AXIMM_${idx}_ARREGION(AP_AXIMM_${idx}_ARREGION),"
	puts $fp "        .AP_AXIMM_${idx}_ARQOS(AP_AXIMM_${idx}_ARQOS),"
#	puts $fp "        .AP_AXIMM_${idx}_ARUSER(AP_AXIMM_${idx}_ARUSER),"
	puts $fp "        .AP_AXIMM_${idx}_ARVALID(AP_AXIMM_${idx}_ARVALID),"
	puts $fp "        .AP_AXIMM_${idx}_ARREADY(AP_AXIMM_${idx}_ARREADY),"
#	puts $fp "        .AP_AXIMM_${idx}_RID(AP_AXIMM_${idx}_RID),"
	puts $fp "        .AP_AXIMM_${idx}_RDATA(AP_AXIMM_${idx}_RDATA),"
	puts $fp "        .AP_AXIMM_${idx}_RRESP(AP_AXIMM_${idx}_RRESP),"
	puts $fp "        .AP_AXIMM_${idx}_RLAST(AP_AXIMM_${idx}_RLAST),"
#	puts $fp "        .AP_AXIMM_${idx}_RUSER(AP_AXIMM_${idx}_RUSER),"
	puts $fp "        .AP_AXIMM_${idx}_RVALID(AP_AXIMM_${idx}_RVALID),"
	puts $fp "        .AP_AXIMM_${idx}_RREADY(AP_AXIMM_${idx}_RREADY),"
#	puts $fp "        .M_AXIMM_${idx}_AWID(M_AXIMM_${idx}_AWID),"
	puts $fp "        .M_AXIMM_${idx}_AWADDR(M_AXIMM_${idx}_AWADDR),"
	puts $fp "        .M_AXIMM_${idx}_AWLEN(M_AXIMM_${idx}_AWLEN),"
	puts $fp "        .M_AXIMM_${idx}_AWSIZE(M_AXIMM_${idx}_AWSIZE),"
	puts $fp "        .M_AXIMM_${idx}_AWBURST(M_AXIMM_${idx}_AWBURST),"
	puts $fp "        .M_AXIMM_${idx}_AWLOCK(M_AXIMM_${idx}_AWLOCK),"
	puts $fp "        .M_AXIMM_${idx}_AWCACHE(M_AXIMM_${idx}_AWCACHE),"
	puts $fp "        .M_AXIMM_${idx}_AWPROT(M_AXIMM_${idx}_AWPROT),"
	puts $fp "        .M_AXIMM_${idx}_AWREGION(M_AXIMM_${idx}_AWREGION),"
	puts $fp "        .M_AXIMM_${idx}_AWQOS(M_AXIMM_${idx}_AWQOS),"
#	puts $fp "        .M_AXIMM_${idx}_AWUSER(M_AXIMM_${idx}_AWUSER),"
	puts $fp "        .M_AXIMM_${idx}_AWVALID(M_AXIMM_${idx}_AWVALID),"
	puts $fp "        .M_AXIMM_${idx}_AWREADY(M_AXIMM_${idx}_AWREADY),"
#	puts $fp "        .M_AXIMM_${idx}_WID(M_AXIMM_${idx}_WID),"
	puts $fp "        .M_AXIMM_${idx}_WDATA(M_AXIMM_${idx}_WDATA),"
	puts $fp "        .M_AXIMM_${idx}_WSTRB(M_AXIMM_${idx}_WSTRB),"
	puts $fp "        .M_AXIMM_${idx}_WLAST(M_AXIMM_${idx}_WLAST),"
#	puts $fp "        .M_AXIMM_${idx}_WUSER(M_AXIMM_${idx}_WUSER),"
	puts $fp "        .M_AXIMM_${idx}_WVALID(M_AXIMM_${idx}_WVALID),"
	puts $fp "        .M_AXIMM_${idx}_WREADY(M_AXIMM_${idx}_WREADY),"
#	puts $fp "        .M_AXIMM_${idx}_BID(M_AXIMM_${idx}_BID),"
	puts $fp "        .M_AXIMM_${idx}_BRESP(M_AXIMM_${idx}_BRESP),"
#	puts $fp "        .M_AXIMM_${idx}_BUSER(M_AXIMM_${idx}_BUSER),"
	puts $fp "        .M_AXIMM_${idx}_BVALID(M_AXIMM_${idx}_BVALID),"
	puts $fp "        .M_AXIMM_${idx}_BREADY(M_AXIMM_${idx}_BREADY),"
#	puts $fp "        .M_AXIMM_${idx}_ARID(M_AXIMM_${idx}_ARID),"
	puts $fp "        .M_AXIMM_${idx}_ARADDR(M_AXIMM_${idx}_ARADDR),"
	puts $fp "        .M_AXIMM_${idx}_ARLEN(M_AXIMM_${idx}_ARLEN),"
	puts $fp "        .M_AXIMM_${idx}_ARSIZE(M_AXIMM_${idx}_ARSIZE),"
	puts $fp "        .M_AXIMM_${idx}_ARBURST(M_AXIMM_${idx}_ARBURST),"
	puts $fp "        .M_AXIMM_${idx}_ARLOCK(M_AXIMM_${idx}_ARLOCK),"
	puts $fp "        .M_AXIMM_${idx}_ARCACHE(M_AXIMM_${idx}_ARCACHE),"
	puts $fp "        .M_AXIMM_${idx}_ARPROT(M_AXIMM_${idx}_ARPROT),"
	puts $fp "        .M_AXIMM_${idx}_ARREGION(M_AXIMM_${idx}_ARREGION),"
	puts $fp "        .M_AXIMM_${idx}_ARQOS(M_AXIMM_${idx}_ARQOS),"
#	puts $fp "        .M_AXIMM_${idx}_ARUSER(M_AXIMM_${idx}_ARUSER),"
	puts $fp "        .M_AXIMM_${idx}_ARVALID(M_AXIMM_${idx}_ARVALID),"
	puts $fp "        .M_AXIMM_${idx}_ARREADY(M_AXIMM_${idx}_ARREADY),"
#	puts $fp "        .M_AXIMM_${idx}_RID(M_AXIMM_${idx}_RID),"
	puts $fp "        .M_AXIMM_${idx}_RDATA(M_AXIMM_${idx}_RDATA),"
	puts $fp "        .M_AXIMM_${idx}_RRESP(M_AXIMM_${idx}_RRESP),"
	puts $fp "        .M_AXIMM_${idx}_RLAST(M_AXIMM_${idx}_RLAST),"
#	puts $fp "        .M_AXIMM_${idx}_RUSER(M_AXIMM_${idx}_RUSER),"
	puts $fp "        .M_AXIMM_${idx}_RVALID(M_AXIMM_${idx}_RVALID),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIMM_${idx}_RREADY(M_AXIMM_${idx}_RREADY),"
	} else {
	    puts $fp "        .M_AXIMM_${idx}_RREADY(M_AXIMM_${idx}_RREADY)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    in_bram_args #("
    puts $fp "        .C_NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_PORTS(S_AXIS_BRAM_${idx}_PORTS),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_WIDTH(S_AXIS_BRAM_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_DEPTH(S_AXIS_BRAM_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_DMWIDTH(S_AXIS_BRAM_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAMIO_${idx}_DMWIDTH(M_AXIS_BRAMIO_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_IS_ASYNC(S_AXIS_BRAM_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAMIO_${idx}_IS_ASYNC(M_AXIS_BRAMIO_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_IS_INOUT(S_AXIS_BRAM_${idx}_IS_INOUT),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .S_AXIS_BRAM_${idx}_MB_DEPTH(S_AXIS_BRAM_${idx}_MB_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .S_AXIS_BRAM_${idx}_ADDR_WIDTH(S_AXIS_BRAM_${idx}_ADDR_WIDTH),"
	} else {
	    puts $fp "        .S_AXIS_BRAM_${idx}_ADDR_WIDTH(S_AXIS_BRAM_${idx}_ADDR_WIDTH)"
	}
    }
    puts $fp "    ) in_bram_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .in_bram_allow_in(inbram_ctrl_allow),"
    puts $fp "        .in_bram_allow_out(outbram_ctrl_allow),"
    puts $fp "        .acc_start(ap_start_single),"
    puts $fp "        .acc_done(ap_done),"
    puts $fp "        .in_bram_ready(inbram_ctrl_ready),"
    puts $fp "        .inout_bram_ready(inoutbram_ctrl_ready),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_bram_${idx}_aclk(s_axis_bram_${idx}_aclk),"
	puts $fp "        .s_axis_bram_${idx}_aresetn(s_axis_bram_${idx}_aresetn),"
	puts $fp "        .s_axis_bram_${idx}_tlast(s_axis_bram_${idx}_tlast),"
	puts $fp "        .s_axis_bram_${idx}_tvalid(s_axis_bram_${idx}_tvalid),"
	puts $fp "        .s_axis_bram_${idx}_tkeep(s_axis_bram_${idx}_tkeep),"
	puts $fp "        .s_axis_bram_${idx}_tstrb(s_axis_bram_${idx}_tstrb),"
	puts $fp "        .s_axis_bram_${idx}_tdata(s_axis_bram_${idx}_tdata),"
	puts $fp "        .s_axis_bram_${idx}_tready(s_axis_bram_${idx}_tready),"
	puts $fp "        .ap_bram_${idx}_addr0(ap_bram_iarg_${idx}_addr0),"
	puts $fp "        .ap_bram_${idx}_din0(ap_bram_iarg_${idx}_din0),"
	puts $fp "        .ap_bram_${idx}_dout0(ap_bram_iarg_${idx}_dout0),"
	puts $fp "        .ap_bram_${idx}_we0(ap_bram_iarg_${idx}_we0),"
	puts $fp "        .ap_bram_${idx}_en0(ap_bram_iarg_${idx}_en0),"
	puts $fp "        .ap_bram_${idx}_addr1(ap_bram_iarg_${idx}_addr1),"
	puts $fp "        .ap_bram_${idx}_din1(ap_bram_iarg_${idx}_din1),"
	puts $fp "        .ap_bram_${idx}_dout1(ap_bram_iarg_${idx}_dout1),"
	puts $fp "        .ap_bram_${idx}_we1(ap_bram_iarg_${idx}_we1),"
	puts $fp "        .ap_bram_${idx}_en1(ap_bram_iarg_${idx}_en1),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_bramio_${idx}_aclk(m_axis_bramio_${idx}_aclk),"
	puts $fp "        .m_axis_bramio_${idx}_aresetn(m_axis_bramio_${idx}_aresetn),"
	puts $fp "        .m_axis_bramio_${idx}_tlast(m_axis_bramio_${idx}_tlast),"
	puts $fp "        .m_axis_bramio_${idx}_tvalid(m_axis_bramio_${idx}_tvalid),"
	puts $fp "        .m_axis_bramio_${idx}_tkeep(m_axis_bramio_${idx}_tkeep),"
	puts $fp "        .m_axis_bramio_${idx}_tstrb(m_axis_bramio_${idx}_tstrb),"
	puts $fp "        .m_axis_bramio_${idx}_tdata(m_axis_bramio_${idx}_tdata),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .m_axis_bramio_${idx}_tready(m_axis_bramio_${idx}_tready),"
	} else {
	    puts $fp "        .m_axis_bramio_${idx}_tready(m_axis_bramio_${idx}_tready)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    out_bram_args #("
    puts $fp "        .C_QUEUE_DEPTH(C_QUEUE_DEPTH),"
    puts $fp "        .C_NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_WIDTH(M_AXIS_BRAM_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_DEPTH(M_AXIS_BRAM_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_DMWIDTH(M_AXIS_BRAM_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_IS_ASYNC(M_AXIS_BRAM_${idx}_IS_ASYNC),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_PORTS(M_AXIS_BRAM_${idx}_PORTS),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .M_AXIS_BRAM_${idx}_MB_DEPTH(M_AXIS_BRAM_${idx}_MB_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .M_AXIS_BRAM_${idx}_ADDR_WIDTH(M_AXIS_BRAM_${idx}_ADDR_WIDTH),"
	} else {
	    puts $fp "        .M_AXIS_BRAM_${idx}_ADDR_WIDTH(M_AXIS_BRAM_${idx}_ADDR_WIDTH)"
	}
    }
    puts $fp "    ) out_bram_args_i ("
    puts $fp "        .acc_clk(acc_aclk),"
    puts $fp "        .acc_aresetn(acc_aresetn),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .dm_aresetn(s_axi_aresetn),"
    puts $fp "        .outbram_allow(outbram_ctrl_allow),"
    puts $fp "        .acc_start(ap_start_single),"
    puts $fp "        .acc_done(ap_done),"
    puts $fp "        .outbram_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_canstart(outbram_ctrl_canstart),"
    puts $fp "        .outbram_depth(outbram_depth),"
    puts $fp "        .outbram_depth_write(outbram_depth_write),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_bram_${idx}_aclk(m_axis_bram_${idx}_aclk),"
	puts $fp "        .m_axis_bram_${idx}_aresetn(m_axis_bram_${idx}_aresetn),"
	puts $fp "        .m_axis_bram_${idx}_tlast(m_axis_bram_${idx}_tlast),"
	puts $fp "        .m_axis_bram_${idx}_tvalid(m_axis_bram_${idx}_tvalid),"
	puts $fp "        .m_axis_bram_${idx}_tkeep(m_axis_bram_${idx}_tkeep),"
	puts $fp "        .m_axis_bram_${idx}_tstrb(m_axis_bram_${idx}_tstrb),"
	puts $fp "        .m_axis_bram_${idx}_tdata(m_axis_bram_${idx}_tdata),"
	puts $fp "        .m_axis_bram_${idx}_tready(m_axis_bram_${idx}_tready),"
	puts $fp "        .ap_bram_${idx}_addr0(ap_bram_oarg_${idx}_addr0),"
	puts $fp "        .ap_bram_${idx}_din0(ap_bram_oarg_${idx}_din0),"
	puts $fp "        .ap_bram_${idx}_dout0(ap_bram_oarg_${idx}_dout0),"
	puts $fp "        .ap_bram_${idx}_we0(ap_bram_oarg_${idx}_we0),"
	puts $fp "        .ap_bram_${idx}_en0(ap_bram_oarg_${idx}_en0),"
	puts $fp "        .ap_bram_${idx}_addr1(ap_bram_oarg_${idx}_addr1),"
	puts $fp "        .ap_bram_${idx}_din1(ap_bram_oarg_${idx}_din1),"
	puts $fp "        .ap_bram_${idx}_dout1(ap_bram_oarg_${idx}_dout1),"
	puts $fp "        .ap_bram_${idx}_we1(ap_bram_oarg_${idx}_we1),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_bram_${idx}_en1(ap_bram_oarg_${idx}_en1),"
	} else {
	    puts $fp "        .ap_bram_${idx}_en1(ap_bram_oarg_${idx}_en1)"
	}
    }
    puts $fp "    );"
    puts $fp ""
    puts $fp "endmodule"

    close $fp
}

#  LocalWords:  idx
